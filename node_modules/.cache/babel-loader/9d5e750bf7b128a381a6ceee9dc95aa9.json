{"ast":null,"code":"'use strict';\n\nvar StringDecoder = require('string_decoder').StringDecoder;\n\nvar decoder = new StringDecoder();\n\nvar ReplyError = require('./replyError');\n\nvar ParserError = require('./parserError');\n\nvar bufferPool = bufferAlloc(32 * 1024);\nvar bufferOffset = 0;\nvar interval = null;\nvar counter = 0;\nvar notDecreased = 0;\nvar isModern = typeof Buffer.allocUnsafe === 'function';\n/**\n * For backwards compatibility\n * @param len\n * @returns {Buffer}\n */\n\nfunction bufferAlloc(len) {\n  return isModern ? Buffer.allocUnsafe(len) : new Buffer(len);\n}\n/**\n * Used for lengths and numbers only, faster perf on arrays / bulks\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseSimpleNumbers(parser) {\n  var offset = parser.offset;\n  var length = parser.buffer.length - 1;\n  var number = 0;\n  var sign = 1;\n\n  if (parser.buffer[offset] === 45) {\n    sign = -1;\n    offset++;\n  }\n\n  while (offset < length) {\n    var c1 = parser.buffer[offset++];\n\n    if (c1 === 13) {\n      // \\r\\n\n      parser.offset = offset + 1;\n      return sign * number;\n    }\n\n    number = number * 10 + (c1 - 48);\n  }\n}\n/**\n * Used for integer numbers in case of the returnNumbers option\n *\n * The maximimum possible integer to use is: Math.floor(Number.MAX_SAFE_INTEGER / 10)\n * Staying in a SMI Math.floor((Math.pow(2, 32) / 10) - 1) is even more efficient though\n *\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseStringNumbers(parser) {\n  var offset = parser.offset;\n  var length = parser.buffer.length - 1;\n  var number = 0;\n  var res = '';\n\n  if (parser.buffer[offset] === 45) {\n    res += '-';\n    offset++;\n  }\n\n  while (offset < length) {\n    var c1 = parser.buffer[offset++];\n\n    if (c1 === 13) {\n      // \\r\\n\n      parser.offset = offset + 1;\n\n      if (number !== 0) {\n        res += number;\n      }\n\n      return res;\n    } else if (number > 429496728) {\n      res += number * 10 + (c1 - 48);\n      number = 0;\n    } else if (c1 === 48 && number === 0) {\n      res += 0;\n    } else {\n      number = number * 10 + (c1 - 48);\n    }\n  }\n}\n/**\n * Returns a string or buffer of the provided offset start and\n * end ranges. Checks `optionReturnBuffers`.\n *\n * If returnBuffers is active, all return values are returned as buffers besides numbers and errors\n *\n * @param parser\n * @param start\n * @param end\n * @returns {*}\n */\n\n\nfunction convertBufferRange(parser, start, end) {\n  parser.offset = end + 2;\n\n  if (parser.optionReturnBuffers === true) {\n    return parser.buffer.slice(start, end);\n  }\n\n  return parser.buffer.toString('utf-8', start, end);\n}\n/**\n * Parse a '+' redis simple string response but forward the offsets\n * onto convertBufferRange to generate a string.\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseSimpleString(parser) {\n  var start = parser.offset;\n  var offset = start;\n  var buffer = parser.buffer;\n  var length = buffer.length - 1;\n\n  while (offset < length) {\n    if (buffer[offset++] === 13) {\n      // \\r\\n\n      return convertBufferRange(parser, start, offset - 1);\n    }\n  }\n}\n/**\n * Returns the string length via parseSimpleNumbers\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseLength(parser) {\n  var string = parseSimpleNumbers(parser);\n\n  if (string !== undefined) {\n    return string;\n  }\n}\n/**\n * Parse a ':' redis integer response\n *\n * If stringNumbers is activated the parser always returns numbers as string\n * This is important for big numbers (number > Math.pow(2, 53)) as js numbers\n * are 64bit floating point numbers with reduced precision\n *\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseInteger(parser) {\n  if (parser.optionStringNumbers) {\n    return parseStringNumbers(parser);\n  }\n\n  return parseSimpleNumbers(parser);\n}\n/**\n * Parse a '$' redis bulk string response\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseBulkString(parser) {\n  var length = parseLength(parser);\n\n  if (length === undefined) {\n    return;\n  }\n\n  if (length === -1) {\n    return null;\n  }\n\n  var offsetEnd = parser.offset + length;\n\n  if (offsetEnd + 2 > parser.buffer.length) {\n    parser.bigStrSize = offsetEnd + 2;\n    parser.bigOffset = parser.offset;\n    parser.totalChunkSize = parser.buffer.length;\n    parser.bufferCache.push(parser.buffer);\n    return;\n  }\n\n  return convertBufferRange(parser, parser.offset, offsetEnd);\n}\n/**\n * Parse a '-' redis error response\n * @param parser\n * @returns {Error}\n */\n\n\nfunction parseError(parser) {\n  var string = parseSimpleString(parser);\n\n  if (string !== undefined) {\n    if (parser.optionReturnBuffers === true) {\n      string = string.toString();\n    }\n\n    return new ReplyError(string);\n  }\n}\n/**\n * Parsing error handler, resets parser buffer\n * @param parser\n * @param error\n */\n\n\nfunction handleError(parser, error) {\n  parser.buffer = null;\n  parser.returnFatalError(error);\n}\n/**\n * Parse a '*' redis array response\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseArray(parser) {\n  var length = parseLength(parser);\n\n  if (length === undefined) {\n    return;\n  }\n\n  if (length === -1) {\n    return null;\n  }\n\n  var responses = new Array(length);\n  return parseArrayElements(parser, responses, 0);\n}\n/**\n * Push a partly parsed array to the stack\n *\n * @param parser\n * @param elem\n * @param i\n * @returns {undefined}\n */\n\n\nfunction pushArrayCache(parser, elem, pos) {\n  parser.arrayCache.push(elem);\n  parser.arrayPos.push(pos);\n}\n/**\n * Parse chunked redis array response\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseArrayChunks(parser) {\n  var tmp = parser.arrayCache.pop();\n  var pos = parser.arrayPos.pop();\n\n  if (parser.arrayCache.length) {\n    var res = parseArrayChunks(parser);\n\n    if (!res) {\n      pushArrayCache(parser, tmp, pos);\n      return;\n    }\n\n    tmp[pos++] = res;\n  }\n\n  return parseArrayElements(parser, tmp, pos);\n}\n/**\n * Parse redis array response elements\n * @param parser\n * @param responses\n * @param i\n * @returns {*}\n */\n\n\nfunction parseArrayElements(parser, responses, i) {\n  var bufferLength = parser.buffer.length;\n\n  while (i < responses.length) {\n    var offset = parser.offset;\n\n    if (parser.offset >= bufferLength) {\n      pushArrayCache(parser, responses, i);\n      return;\n    }\n\n    var response = parseType(parser, parser.buffer[parser.offset++]);\n\n    if (response === undefined) {\n      if (!parser.arrayCache.length) {\n        parser.offset = offset;\n      }\n\n      pushArrayCache(parser, responses, i);\n      return;\n    }\n\n    responses[i] = response;\n    i++;\n  }\n\n  return responses;\n}\n/**\n * Called the appropriate parser for the specified type.\n * @param parser\n * @param type\n * @returns {*}\n */\n\n\nfunction parseType(parser, type) {\n  switch (type) {\n    case 36:\n      // $\n      return parseBulkString(parser);\n\n    case 58:\n      // :\n      return parseInteger(parser);\n\n    case 43:\n      // +\n      return parseSimpleString(parser);\n\n    case 42:\n      // *\n      return parseArray(parser);\n\n    case 45:\n      // -\n      return parseError(parser);\n\n    default:\n      return handleError(parser, new ParserError('Protocol error, got ' + JSON.stringify(String.fromCharCode(type)) + ' as reply type byte', JSON.stringify(parser.buffer), parser.offset));\n  }\n} // All allowed options including their typeof value\n\n\nvar optionTypes = {\n  returnError: 'function',\n  returnFatalError: 'function',\n  returnReply: 'function',\n  returnBuffers: 'boolean',\n  stringNumbers: 'boolean',\n  name: 'string'\n};\n/**\n * Javascript Redis Parser\n * @param options\n * @constructor\n */\n\nfunction JavascriptRedisParser(options) {\n  if (!(this instanceof JavascriptRedisParser)) {\n    return new JavascriptRedisParser(options);\n  }\n\n  if (!options || !options.returnError || !options.returnReply) {\n    throw new TypeError('Please provide all return functions while initiating the parser');\n  }\n\n  for (var key in options) {\n    // eslint-disable-next-line valid-typeof\n    if (optionTypes.hasOwnProperty(key) && typeof options[key] !== optionTypes[key]) {\n      throw new TypeError('The options argument contains the property \"' + key + '\" that is either unknown or of a wrong type');\n    }\n  }\n\n  if (options.name === 'hiredis') {\n    /* istanbul ignore next: hiredis is only supported for legacy usage */\n    try {\n      var Hiredis = require('./hiredis');\n\n      console.error(new TypeError('Using hiredis is discouraged. Please use the faster JS parser by removing the name option.').stack.replace('Error', 'Warning'));\n      return new Hiredis(options);\n    } catch (e) {\n      console.error(new TypeError('Hiredis is not installed. Please remove the `name` option. The (faster) JS parser is used instead.').stack.replace('Error', 'Warning'));\n    }\n  }\n\n  this.optionReturnBuffers = !!options.returnBuffers;\n  this.optionStringNumbers = !!options.stringNumbers;\n  this.returnError = options.returnError;\n  this.returnFatalError = options.returnFatalError || options.returnError;\n  this.returnReply = options.returnReply;\n  this.name = 'javascript';\n  this.reset();\n}\n/**\n * Reset the parser values to the initial state\n *\n * @returns {undefined}\n */\n\n\nJavascriptRedisParser.prototype.reset = function () {\n  this.offset = 0;\n  this.buffer = null;\n  this.bigStrSize = 0;\n  this.bigOffset = 0;\n  this.totalChunkSize = 0;\n  this.bufferCache = [];\n  this.arrayCache = [];\n  this.arrayPos = [];\n};\n/**\n * Set the returnBuffers option\n *\n * @param returnBuffers\n * @returns {undefined}\n */\n\n\nJavascriptRedisParser.prototype.setReturnBuffers = function (returnBuffers) {\n  if (typeof returnBuffers !== 'boolean') {\n    throw new TypeError('The returnBuffers argument has to be a boolean');\n  }\n\n  this.optionReturnBuffers = returnBuffers;\n};\n/**\n * Set the stringNumbers option\n *\n * @param stringNumbers\n * @returns {undefined}\n */\n\n\nJavascriptRedisParser.prototype.setStringNumbers = function (stringNumbers) {\n  if (typeof stringNumbers !== 'boolean') {\n    throw new TypeError('The stringNumbers argument has to be a boolean');\n  }\n\n  this.optionStringNumbers = stringNumbers;\n};\n/**\n * Decrease the bufferPool size over time\n * @returns {undefined}\n */\n\n\nfunction decreaseBufferPool() {\n  if (bufferPool.length > 50 * 1024) {\n    // Balance between increasing and decreasing the bufferPool\n    if (counter === 1 || notDecreased > counter * 2) {\n      // Decrease the bufferPool by 10% by removing the first 10% of the current pool\n      var sliceLength = Math.floor(bufferPool.length / 10);\n\n      if (bufferOffset <= sliceLength) {\n        bufferOffset = 0;\n      } else {\n        bufferOffset -= sliceLength;\n      }\n\n      bufferPool = bufferPool.slice(sliceLength, bufferPool.length);\n    } else {\n      notDecreased++;\n      counter--;\n    }\n  } else {\n    clearInterval(interval);\n    counter = 0;\n    notDecreased = 0;\n    interval = null;\n  }\n}\n/**\n * Check if the requested size fits in the current bufferPool.\n * If it does not, reset and increase the bufferPool accordingly.\n *\n * @param length\n * @returns {undefined}\n */\n\n\nfunction resizeBuffer(length) {\n  if (bufferPool.length < length + bufferOffset) {\n    var multiplier = length > 1024 * 1024 * 75 ? 2 : 3;\n\n    if (bufferOffset > 1024 * 1024 * 111) {\n      bufferOffset = 1024 * 1024 * 50;\n    }\n\n    bufferPool = bufferAlloc(length * multiplier + bufferOffset);\n    bufferOffset = 0;\n    counter++;\n\n    if (interval === null) {\n      interval = setInterval(decreaseBufferPool, 50);\n    }\n  }\n}\n/**\n * Concat a bulk string containing multiple chunks\n *\n * Notes:\n * 1) The first chunk might contain the whole bulk string including the \\r\n * 2) We are only safe to fully add up elements that are neither the first nor any of the last two elements\n *\n * @param parser\n * @returns {String}\n */\n\n\nfunction concatBulkString(parser) {\n  var list = parser.bufferCache;\n  var chunks = list.length;\n  var offset = parser.bigStrSize - parser.totalChunkSize;\n  parser.offset = offset;\n\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].toString('utf8', parser.bigOffset, list[0].length + offset - 2);\n    }\n\n    chunks--;\n    offset = list[list.length - 2].length + offset;\n  }\n\n  var res = decoder.write(list[0].slice(parser.bigOffset));\n\n  for (var i = 1; i < chunks - 1; i++) {\n    res += decoder.write(list[i]);\n  }\n\n  res += decoder.end(list[i].slice(0, offset - 2));\n  return res;\n}\n/**\n * Concat the collected chunks from parser.bufferCache.\n *\n * Increases the bufferPool size beforehand if necessary.\n *\n * @param parser\n * @returns {Buffer}\n */\n\n\nfunction concatBulkBuffer(parser) {\n  var list = parser.bufferCache;\n  var chunks = list.length;\n  var length = parser.bigStrSize - parser.bigOffset - 2;\n  var offset = parser.bigStrSize - parser.totalChunkSize;\n  parser.offset = offset;\n\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].slice(parser.bigOffset, list[0].length + offset - 2);\n    }\n\n    chunks--;\n    offset = list[list.length - 2].length + offset;\n  }\n\n  resizeBuffer(length);\n  var start = bufferOffset;\n  list[0].copy(bufferPool, start, parser.bigOffset, list[0].length);\n  bufferOffset += list[0].length - parser.bigOffset;\n\n  for (var i = 1; i < chunks - 1; i++) {\n    list[i].copy(bufferPool, bufferOffset);\n    bufferOffset += list[i].length;\n  }\n\n  list[i].copy(bufferPool, bufferOffset, 0, offset - 2);\n  bufferOffset += offset - 2;\n  return bufferPool.slice(start, bufferOffset);\n}\n/**\n * Parse the redis buffer\n * @param buffer\n * @returns {undefined}\n */\n\n\nJavascriptRedisParser.prototype.execute = function execute(buffer) {\n  if (this.buffer === null) {\n    this.buffer = buffer;\n    this.offset = 0;\n  } else if (this.bigStrSize === 0) {\n    var oldLength = this.buffer.length;\n    var remainingLength = oldLength - this.offset;\n    var newBuffer = bufferAlloc(remainingLength + buffer.length);\n    this.buffer.copy(newBuffer, 0, this.offset, oldLength);\n    buffer.copy(newBuffer, remainingLength, 0, buffer.length);\n    this.buffer = newBuffer;\n    this.offset = 0;\n\n    if (this.arrayCache.length) {\n      var arr = parseArrayChunks(this);\n\n      if (!arr) {\n        return;\n      }\n\n      this.returnReply(arr);\n    }\n  } else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {\n    this.bufferCache.push(buffer);\n    var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this);\n    this.bigStrSize = 0;\n    this.bufferCache = [];\n    this.buffer = buffer;\n\n    if (this.arrayCache.length) {\n      this.arrayCache[0][this.arrayPos[0]++] = tmp;\n      tmp = parseArrayChunks(this);\n\n      if (!tmp) {\n        return;\n      }\n    }\n\n    this.returnReply(tmp);\n  } else {\n    this.bufferCache.push(buffer);\n    this.totalChunkSize += buffer.length;\n    return;\n  }\n\n  while (this.offset < this.buffer.length) {\n    var offset = this.offset;\n    var type = this.buffer[this.offset++];\n    var response = parseType(this, type);\n\n    if (response === undefined) {\n      if (!this.arrayCache.length) {\n        this.offset = offset;\n      }\n\n      return;\n    }\n\n    if (type === 45) {\n      this.returnError(response);\n    } else {\n      this.returnReply(response);\n    }\n  }\n\n  this.buffer = null;\n};\n\nmodule.exports = JavascriptRedisParser;","map":{"version":3,"sources":["/Users/erinx/code/hyperplaneReact/road-to-react/js-job-board-diy/node_modules/redis-parser/lib/parser.js"],"names":["StringDecoder","require","decoder","ReplyError","ParserError","bufferPool","bufferAlloc","bufferOffset","interval","counter","notDecreased","isModern","Buffer","allocUnsafe","len","parseSimpleNumbers","parser","offset","length","buffer","number","sign","c1","parseStringNumbers","res","convertBufferRange","start","end","optionReturnBuffers","slice","toString","parseSimpleString","parseLength","string","undefined","parseInteger","optionStringNumbers","parseBulkString","offsetEnd","bigStrSize","bigOffset","totalChunkSize","bufferCache","push","parseError","handleError","error","returnFatalError","parseArray","responses","Array","parseArrayElements","pushArrayCache","elem","pos","arrayCache","arrayPos","parseArrayChunks","tmp","pop","i","bufferLength","response","parseType","type","JSON","stringify","String","fromCharCode","optionTypes","returnError","returnReply","returnBuffers","stringNumbers","name","JavascriptRedisParser","options","TypeError","key","hasOwnProperty","Hiredis","console","stack","replace","e","reset","prototype","setReturnBuffers","setStringNumbers","decreaseBufferPool","sliceLength","Math","floor","clearInterval","resizeBuffer","multiplier","setInterval","concatBulkString","list","chunks","write","concatBulkBuffer","copy","execute","oldLength","remainingLength","newBuffer","arr","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,aAAa,GAAGC,OAAO,CAAC,gBAAD,CAAP,CAA0BD,aAA9C;;AACA,IAAIE,OAAO,GAAG,IAAIF,aAAJ,EAAd;;AACA,IAAIG,UAAU,GAAGF,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIG,WAAW,GAAGH,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAII,UAAU,GAAGC,WAAW,CAAC,KAAK,IAAN,CAA5B;AACA,IAAIC,YAAY,GAAG,CAAnB;AACA,IAAIC,QAAQ,GAAG,IAAf;AACA,IAAIC,OAAO,GAAG,CAAd;AACA,IAAIC,YAAY,GAAG,CAAnB;AACA,IAAIC,QAAQ,GAAG,OAAOC,MAAM,CAACC,WAAd,KAA8B,UAA7C;AAEA;;;;;;AAMA,SAASP,WAAT,CAAsBQ,GAAtB,EAA2B;AACzB,SAAOH,QAAQ,GAAGC,MAAM,CAACC,WAAP,CAAmBC,GAAnB,CAAH,GAA6B,IAAIF,MAAJ,CAAWE,GAAX,CAA5C;AACD;AAED;;;;;;;AAKA,SAASC,kBAAT,CAA6BC,MAA7B,EAAqC;AACnC,MAAIC,MAAM,GAAGD,MAAM,CAACC,MAApB;AACA,MAAIC,MAAM,GAAGF,MAAM,CAACG,MAAP,CAAcD,MAAd,GAAuB,CAApC;AACA,MAAIE,MAAM,GAAG,CAAb;AACA,MAAIC,IAAI,GAAG,CAAX;;AAEA,MAAIL,MAAM,CAACG,MAAP,CAAcF,MAAd,MAA0B,EAA9B,EAAkC;AAChCI,IAAAA,IAAI,GAAG,CAAC,CAAR;AACAJ,IAAAA,MAAM;AACP;;AAED,SAAOA,MAAM,GAAGC,MAAhB,EAAwB;AACtB,QAAII,EAAE,GAAGN,MAAM,CAACG,MAAP,CAAcF,MAAM,EAApB,CAAT;;AACA,QAAIK,EAAE,KAAK,EAAX,EAAe;AAAE;AACfN,MAAAA,MAAM,CAACC,MAAP,GAAgBA,MAAM,GAAG,CAAzB;AACA,aAAOI,IAAI,GAAGD,MAAd;AACD;;AACDA,IAAAA,MAAM,GAAIA,MAAM,GAAG,EAAV,IAAiBE,EAAE,GAAG,EAAtB,CAAT;AACD;AACF;AAED;;;;;;;;;;;AASA,SAASC,kBAAT,CAA6BP,MAA7B,EAAqC;AACnC,MAAIC,MAAM,GAAGD,MAAM,CAACC,MAApB;AACA,MAAIC,MAAM,GAAGF,MAAM,CAACG,MAAP,CAAcD,MAAd,GAAuB,CAApC;AACA,MAAIE,MAAM,GAAG,CAAb;AACA,MAAII,GAAG,GAAG,EAAV;;AAEA,MAAIR,MAAM,CAACG,MAAP,CAAcF,MAAd,MAA0B,EAA9B,EAAkC;AAChCO,IAAAA,GAAG,IAAI,GAAP;AACAP,IAAAA,MAAM;AACP;;AAED,SAAOA,MAAM,GAAGC,MAAhB,EAAwB;AACtB,QAAII,EAAE,GAAGN,MAAM,CAACG,MAAP,CAAcF,MAAM,EAApB,CAAT;;AACA,QAAIK,EAAE,KAAK,EAAX,EAAe;AAAE;AACfN,MAAAA,MAAM,CAACC,MAAP,GAAgBA,MAAM,GAAG,CAAzB;;AACA,UAAIG,MAAM,KAAK,CAAf,EAAkB;AAChBI,QAAAA,GAAG,IAAIJ,MAAP;AACD;;AACD,aAAOI,GAAP;AACD,KAND,MAMO,IAAIJ,MAAM,GAAG,SAAb,EAAwB;AAC7BI,MAAAA,GAAG,IAAKJ,MAAM,GAAG,EAAV,IAAiBE,EAAE,GAAG,EAAtB,CAAP;AACAF,MAAAA,MAAM,GAAG,CAAT;AACD,KAHM,MAGA,IAAIE,EAAE,KAAK,EAAP,IAAaF,MAAM,KAAK,CAA5B,EAA+B;AACpCI,MAAAA,GAAG,IAAI,CAAP;AACD,KAFM,MAEA;AACLJ,MAAAA,MAAM,GAAIA,MAAM,GAAG,EAAV,IAAiBE,EAAE,GAAG,EAAtB,CAAT;AACD;AACF;AACF;AAED;;;;;;;;;;;;;AAWA,SAASG,kBAAT,CAA6BT,MAA7B,EAAqCU,KAArC,EAA4CC,GAA5C,EAAiD;AAC/CX,EAAAA,MAAM,CAACC,MAAP,GAAgBU,GAAG,GAAG,CAAtB;;AACA,MAAIX,MAAM,CAACY,mBAAP,KAA+B,IAAnC,EAAyC;AACvC,WAAOZ,MAAM,CAACG,MAAP,CAAcU,KAAd,CAAoBH,KAApB,EAA2BC,GAA3B,CAAP;AACD;;AAED,SAAOX,MAAM,CAACG,MAAP,CAAcW,QAAd,CAAuB,OAAvB,EAAgCJ,KAAhC,EAAuCC,GAAvC,CAAP;AACD;AAED;;;;;;;;AAMA,SAASI,iBAAT,CAA4Bf,MAA5B,EAAoC;AAClC,MAAIU,KAAK,GAAGV,MAAM,CAACC,MAAnB;AACA,MAAIA,MAAM,GAAGS,KAAb;AACA,MAAIP,MAAM,GAAGH,MAAM,CAACG,MAApB;AACA,MAAID,MAAM,GAAGC,MAAM,CAACD,MAAP,GAAgB,CAA7B;;AAEA,SAAOD,MAAM,GAAGC,MAAhB,EAAwB;AACtB,QAAIC,MAAM,CAACF,MAAM,EAAP,CAAN,KAAqB,EAAzB,EAA6B;AAAE;AAC7B,aAAOQ,kBAAkB,CAACT,MAAD,EAASU,KAAT,EAAgBT,MAAM,GAAG,CAAzB,CAAzB;AACD;AACF;AACF;AAED;;;;;;;AAKA,SAASe,WAAT,CAAsBhB,MAAtB,EAA8B;AAC5B,MAAIiB,MAAM,GAAGlB,kBAAkB,CAACC,MAAD,CAA/B;;AACA,MAAIiB,MAAM,KAAKC,SAAf,EAA0B;AACxB,WAAOD,MAAP;AACD;AACF;AAED;;;;;;;;;;;;AAUA,SAASE,YAAT,CAAuBnB,MAAvB,EAA+B;AAC7B,MAAIA,MAAM,CAACoB,mBAAX,EAAgC;AAC9B,WAAOb,kBAAkB,CAACP,MAAD,CAAzB;AACD;;AACD,SAAOD,kBAAkB,CAACC,MAAD,CAAzB;AACD;AAED;;;;;;;AAKA,SAASqB,eAAT,CAA0BrB,MAA1B,EAAkC;AAChC,MAAIE,MAAM,GAAGc,WAAW,CAAChB,MAAD,CAAxB;;AACA,MAAIE,MAAM,KAAKgB,SAAf,EAA0B;AACxB;AACD;;AACD,MAAIhB,MAAM,KAAK,CAAC,CAAhB,EAAmB;AACjB,WAAO,IAAP;AACD;;AACD,MAAIoB,SAAS,GAAGtB,MAAM,CAACC,MAAP,GAAgBC,MAAhC;;AACA,MAAIoB,SAAS,GAAG,CAAZ,GAAgBtB,MAAM,CAACG,MAAP,CAAcD,MAAlC,EAA0C;AACxCF,IAAAA,MAAM,CAACuB,UAAP,GAAoBD,SAAS,GAAG,CAAhC;AACAtB,IAAAA,MAAM,CAACwB,SAAP,GAAmBxB,MAAM,CAACC,MAA1B;AACAD,IAAAA,MAAM,CAACyB,cAAP,GAAwBzB,MAAM,CAACG,MAAP,CAAcD,MAAtC;AACAF,IAAAA,MAAM,CAAC0B,WAAP,CAAmBC,IAAnB,CAAwB3B,MAAM,CAACG,MAA/B;AACA;AACD;;AAED,SAAOM,kBAAkB,CAACT,MAAD,EAASA,MAAM,CAACC,MAAhB,EAAwBqB,SAAxB,CAAzB;AACD;AAED;;;;;;;AAKA,SAASM,UAAT,CAAqB5B,MAArB,EAA6B;AAC3B,MAAIiB,MAAM,GAAGF,iBAAiB,CAACf,MAAD,CAA9B;;AACA,MAAIiB,MAAM,KAAKC,SAAf,EAA0B;AACxB,QAAIlB,MAAM,CAACY,mBAAP,KAA+B,IAAnC,EAAyC;AACvCK,MAAAA,MAAM,GAAGA,MAAM,CAACH,QAAP,EAAT;AACD;;AACD,WAAO,IAAI3B,UAAJ,CAAe8B,MAAf,CAAP;AACD;AACF;AAED;;;;;;;AAKA,SAASY,WAAT,CAAsB7B,MAAtB,EAA8B8B,KAA9B,EAAqC;AACnC9B,EAAAA,MAAM,CAACG,MAAP,GAAgB,IAAhB;AACAH,EAAAA,MAAM,CAAC+B,gBAAP,CAAwBD,KAAxB;AACD;AAED;;;;;;;AAKA,SAASE,UAAT,CAAqBhC,MAArB,EAA6B;AAC3B,MAAIE,MAAM,GAAGc,WAAW,CAAChB,MAAD,CAAxB;;AACA,MAAIE,MAAM,KAAKgB,SAAf,EAA0B;AACxB;AACD;;AACD,MAAIhB,MAAM,KAAK,CAAC,CAAhB,EAAmB;AACjB,WAAO,IAAP;AACD;;AACD,MAAI+B,SAAS,GAAG,IAAIC,KAAJ,CAAUhC,MAAV,CAAhB;AACA,SAAOiC,kBAAkB,CAACnC,MAAD,EAASiC,SAAT,EAAoB,CAApB,CAAzB;AACD;AAED;;;;;;;;;;AAQA,SAASG,cAAT,CAAyBpC,MAAzB,EAAiCqC,IAAjC,EAAuCC,GAAvC,EAA4C;AAC1CtC,EAAAA,MAAM,CAACuC,UAAP,CAAkBZ,IAAlB,CAAuBU,IAAvB;AACArC,EAAAA,MAAM,CAACwC,QAAP,CAAgBb,IAAhB,CAAqBW,GAArB;AACD;AAED;;;;;;;AAKA,SAASG,gBAAT,CAA2BzC,MAA3B,EAAmC;AACjC,MAAI0C,GAAG,GAAG1C,MAAM,CAACuC,UAAP,CAAkBI,GAAlB,EAAV;AACA,MAAIL,GAAG,GAAGtC,MAAM,CAACwC,QAAP,CAAgBG,GAAhB,EAAV;;AACA,MAAI3C,MAAM,CAACuC,UAAP,CAAkBrC,MAAtB,EAA8B;AAC5B,QAAIM,GAAG,GAAGiC,gBAAgB,CAACzC,MAAD,CAA1B;;AACA,QAAI,CAACQ,GAAL,EAAU;AACR4B,MAAAA,cAAc,CAACpC,MAAD,EAAS0C,GAAT,EAAcJ,GAAd,CAAd;AACA;AACD;;AACDI,IAAAA,GAAG,CAACJ,GAAG,EAAJ,CAAH,GAAa9B,GAAb;AACD;;AACD,SAAO2B,kBAAkB,CAACnC,MAAD,EAAS0C,GAAT,EAAcJ,GAAd,CAAzB;AACD;AAED;;;;;;;;;AAOA,SAASH,kBAAT,CAA6BnC,MAA7B,EAAqCiC,SAArC,EAAgDW,CAAhD,EAAmD;AACjD,MAAIC,YAAY,GAAG7C,MAAM,CAACG,MAAP,CAAcD,MAAjC;;AACA,SAAO0C,CAAC,GAAGX,SAAS,CAAC/B,MAArB,EAA6B;AAC3B,QAAID,MAAM,GAAGD,MAAM,CAACC,MAApB;;AACA,QAAID,MAAM,CAACC,MAAP,IAAiB4C,YAArB,EAAmC;AACjCT,MAAAA,cAAc,CAACpC,MAAD,EAASiC,SAAT,EAAoBW,CAApB,CAAd;AACA;AACD;;AACD,QAAIE,QAAQ,GAAGC,SAAS,CAAC/C,MAAD,EAASA,MAAM,CAACG,MAAP,CAAcH,MAAM,CAACC,MAAP,EAAd,CAAT,CAAxB;;AACA,QAAI6C,QAAQ,KAAK5B,SAAjB,EAA4B;AAC1B,UAAI,CAAClB,MAAM,CAACuC,UAAP,CAAkBrC,MAAvB,EAA+B;AAC7BF,QAAAA,MAAM,CAACC,MAAP,GAAgBA,MAAhB;AACD;;AACDmC,MAAAA,cAAc,CAACpC,MAAD,EAASiC,SAAT,EAAoBW,CAApB,CAAd;AACA;AACD;;AACDX,IAAAA,SAAS,CAACW,CAAD,CAAT,GAAeE,QAAf;AACAF,IAAAA,CAAC;AACF;;AAED,SAAOX,SAAP;AACD;AAED;;;;;;;;AAMA,SAASc,SAAT,CAAoB/C,MAApB,EAA4BgD,IAA5B,EAAkC;AAChC,UAAQA,IAAR;AACE,SAAK,EAAL;AAAS;AACP,aAAO3B,eAAe,CAACrB,MAAD,CAAtB;;AACF,SAAK,EAAL;AAAS;AACP,aAAOmB,YAAY,CAACnB,MAAD,CAAnB;;AACF,SAAK,EAAL;AAAS;AACP,aAAOe,iBAAiB,CAACf,MAAD,CAAxB;;AACF,SAAK,EAAL;AAAS;AACP,aAAOgC,UAAU,CAAChC,MAAD,CAAjB;;AACF,SAAK,EAAL;AAAS;AACP,aAAO4B,UAAU,CAAC5B,MAAD,CAAjB;;AACF;AACE,aAAO6B,WAAW,CAAC7B,MAAD,EAAS,IAAIZ,WAAJ,CACzB,yBAAyB6D,IAAI,CAACC,SAAL,CAAeC,MAAM,CAACC,YAAP,CAAoBJ,IAApB,CAAf,CAAzB,GAAqE,qBAD5C,EAEzBC,IAAI,CAACC,SAAL,CAAelD,MAAM,CAACG,MAAtB,CAFyB,EAGzBH,MAAM,CAACC,MAHkB,CAAT,CAAlB;AAZJ;AAkBD,C,CAED;;;AACA,IAAIoD,WAAW,GAAG;AAChBC,EAAAA,WAAW,EAAE,UADG;AAEhBvB,EAAAA,gBAAgB,EAAE,UAFF;AAGhBwB,EAAAA,WAAW,EAAE,UAHG;AAIhBC,EAAAA,aAAa,EAAE,SAJC;AAKhBC,EAAAA,aAAa,EAAE,SALC;AAMhBC,EAAAA,IAAI,EAAE;AANU,CAAlB;AASA;;;;;;AAKA,SAASC,qBAAT,CAAgCC,OAAhC,EAAyC;AACvC,MAAI,EAAE,gBAAgBD,qBAAlB,CAAJ,EAA8C;AAC5C,WAAO,IAAIA,qBAAJ,CAA0BC,OAA1B,CAAP;AACD;;AACD,MAAI,CAACA,OAAD,IAAY,CAACA,OAAO,CAACN,WAArB,IAAoC,CAACM,OAAO,CAACL,WAAjD,EAA8D;AAC5D,UAAM,IAAIM,SAAJ,CAAc,iEAAd,CAAN;AACD;;AACD,OAAK,IAAIC,GAAT,IAAgBF,OAAhB,EAAyB;AACvB;AACA,QAAIP,WAAW,CAACU,cAAZ,CAA2BD,GAA3B,KAAmC,OAAOF,OAAO,CAACE,GAAD,CAAd,KAAwBT,WAAW,CAACS,GAAD,CAA1E,EAAiF;AAC/E,YAAM,IAAID,SAAJ,CAAc,iDAAiDC,GAAjD,GAAuD,6CAArE,CAAN;AACD;AACF;;AACD,MAAIF,OAAO,CAACF,IAAR,KAAiB,SAArB,EAAgC;AAC9B;AACA,QAAI;AACF,UAAIM,OAAO,GAAG/E,OAAO,CAAC,WAAD,CAArB;;AACAgF,MAAAA,OAAO,CAACnC,KAAR,CAAc,IAAI+B,SAAJ,CAAc,4FAAd,EAA4GK,KAA5G,CAAkHC,OAAlH,CAA0H,OAA1H,EAAmI,SAAnI,CAAd;AACA,aAAO,IAAIH,OAAJ,CAAYJ,OAAZ,CAAP;AACD,KAJD,CAIE,OAAOQ,CAAP,EAAU;AACVH,MAAAA,OAAO,CAACnC,KAAR,CAAc,IAAI+B,SAAJ,CAAc,oGAAd,EAAoHK,KAApH,CAA0HC,OAA1H,CAAkI,OAAlI,EAA2I,SAA3I,CAAd;AACD;AACF;;AACD,OAAKvD,mBAAL,GAA2B,CAAC,CAACgD,OAAO,CAACJ,aAArC;AACA,OAAKpC,mBAAL,GAA2B,CAAC,CAACwC,OAAO,CAACH,aAArC;AACA,OAAKH,WAAL,GAAmBM,OAAO,CAACN,WAA3B;AACA,OAAKvB,gBAAL,GAAwB6B,OAAO,CAAC7B,gBAAR,IAA4B6B,OAAO,CAACN,WAA5D;AACA,OAAKC,WAAL,GAAmBK,OAAO,CAACL,WAA3B;AACA,OAAKG,IAAL,GAAY,YAAZ;AACA,OAAKW,KAAL;AACD;AAED;;;;;;;AAKAV,qBAAqB,CAACW,SAAtB,CAAgCD,KAAhC,GAAwC,YAAY;AAClD,OAAKpE,MAAL,GAAc,CAAd;AACA,OAAKE,MAAL,GAAc,IAAd;AACA,OAAKoB,UAAL,GAAkB,CAAlB;AACA,OAAKC,SAAL,GAAiB,CAAjB;AACA,OAAKC,cAAL,GAAsB,CAAtB;AACA,OAAKC,WAAL,GAAmB,EAAnB;AACA,OAAKa,UAAL,GAAkB,EAAlB;AACA,OAAKC,QAAL,GAAgB,EAAhB;AACD,CATD;AAWA;;;;;;;;AAMAmB,qBAAqB,CAACW,SAAtB,CAAgCC,gBAAhC,GAAmD,UAAUf,aAAV,EAAyB;AAC1E,MAAI,OAAOA,aAAP,KAAyB,SAA7B,EAAwC;AACtC,UAAM,IAAIK,SAAJ,CAAc,gDAAd,CAAN;AACD;;AACD,OAAKjD,mBAAL,GAA2B4C,aAA3B;AACD,CALD;AAOA;;;;;;;;AAMAG,qBAAqB,CAACW,SAAtB,CAAgCE,gBAAhC,GAAmD,UAAUf,aAAV,EAAyB;AAC1E,MAAI,OAAOA,aAAP,KAAyB,SAA7B,EAAwC;AACtC,UAAM,IAAII,SAAJ,CAAc,gDAAd,CAAN;AACD;;AACD,OAAKzC,mBAAL,GAA2BqC,aAA3B;AACD,CALD;AAOA;;;;;;AAIA,SAASgB,kBAAT,GAA+B;AAC7B,MAAIpF,UAAU,CAACa,MAAX,GAAoB,KAAK,IAA7B,EAAmC;AACjC;AACA,QAAIT,OAAO,KAAK,CAAZ,IAAiBC,YAAY,GAAGD,OAAO,GAAG,CAA9C,EAAiD;AAC/C;AACA,UAAIiF,WAAW,GAAGC,IAAI,CAACC,KAAL,CAAWvF,UAAU,CAACa,MAAX,GAAoB,EAA/B,CAAlB;;AACA,UAAIX,YAAY,IAAImF,WAApB,EAAiC;AAC/BnF,QAAAA,YAAY,GAAG,CAAf;AACD,OAFD,MAEO;AACLA,QAAAA,YAAY,IAAImF,WAAhB;AACD;;AACDrF,MAAAA,UAAU,GAAGA,UAAU,CAACwB,KAAX,CAAiB6D,WAAjB,EAA8BrF,UAAU,CAACa,MAAzC,CAAb;AACD,KATD,MASO;AACLR,MAAAA,YAAY;AACZD,MAAAA,OAAO;AACR;AACF,GAfD,MAeO;AACLoF,IAAAA,aAAa,CAACrF,QAAD,CAAb;AACAC,IAAAA,OAAO,GAAG,CAAV;AACAC,IAAAA,YAAY,GAAG,CAAf;AACAF,IAAAA,QAAQ,GAAG,IAAX;AACD;AACF;AAED;;;;;;;;;AAOA,SAASsF,YAAT,CAAuB5E,MAAvB,EAA+B;AAC7B,MAAIb,UAAU,CAACa,MAAX,GAAoBA,MAAM,GAAGX,YAAjC,EAA+C;AAC7C,QAAIwF,UAAU,GAAG7E,MAAM,GAAG,OAAO,IAAP,GAAc,EAAvB,GAA4B,CAA5B,GAAgC,CAAjD;;AACA,QAAIX,YAAY,GAAG,OAAO,IAAP,GAAc,GAAjC,EAAsC;AACpCA,MAAAA,YAAY,GAAG,OAAO,IAAP,GAAc,EAA7B;AACD;;AACDF,IAAAA,UAAU,GAAGC,WAAW,CAACY,MAAM,GAAG6E,UAAT,GAAsBxF,YAAvB,CAAxB;AACAA,IAAAA,YAAY,GAAG,CAAf;AACAE,IAAAA,OAAO;;AACP,QAAID,QAAQ,KAAK,IAAjB,EAAuB;AACrBA,MAAAA,QAAQ,GAAGwF,WAAW,CAACP,kBAAD,EAAqB,EAArB,CAAtB;AACD;AACF;AACF;AAED;;;;;;;;;;;;AAUA,SAASQ,gBAAT,CAA2BjF,MAA3B,EAAmC;AACjC,MAAIkF,IAAI,GAAGlF,MAAM,CAAC0B,WAAlB;AACA,MAAIyD,MAAM,GAAGD,IAAI,CAAChF,MAAlB;AACA,MAAID,MAAM,GAAGD,MAAM,CAACuB,UAAP,GAAoBvB,MAAM,CAACyB,cAAxC;AACAzB,EAAAA,MAAM,CAACC,MAAP,GAAgBA,MAAhB;;AACA,MAAIA,MAAM,IAAI,CAAd,EAAiB;AACf,QAAIkF,MAAM,KAAK,CAAf,EAAkB;AAChB,aAAOD,IAAI,CAAC,CAAD,CAAJ,CAAQpE,QAAR,CAAiB,MAAjB,EAAyBd,MAAM,CAACwB,SAAhC,EAA2C0D,IAAI,CAAC,CAAD,CAAJ,CAAQhF,MAAR,GAAiBD,MAAjB,GAA0B,CAArE,CAAP;AACD;;AACDkF,IAAAA,MAAM;AACNlF,IAAAA,MAAM,GAAGiF,IAAI,CAACA,IAAI,CAAChF,MAAL,GAAc,CAAf,CAAJ,CAAsBA,MAAtB,GAA+BD,MAAxC;AACD;;AACD,MAAIO,GAAG,GAAGtB,OAAO,CAACkG,KAAR,CAAcF,IAAI,CAAC,CAAD,CAAJ,CAAQrE,KAAR,CAAcb,MAAM,CAACwB,SAArB,CAAd,CAAV;;AACA,OAAK,IAAIoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuC,MAAM,GAAG,CAA7B,EAAgCvC,CAAC,EAAjC,EAAqC;AACnCpC,IAAAA,GAAG,IAAItB,OAAO,CAACkG,KAAR,CAAcF,IAAI,CAACtC,CAAD,CAAlB,CAAP;AACD;;AACDpC,EAAAA,GAAG,IAAItB,OAAO,CAACyB,GAAR,CAAYuE,IAAI,CAACtC,CAAD,CAAJ,CAAQ/B,KAAR,CAAc,CAAd,EAAiBZ,MAAM,GAAG,CAA1B,CAAZ,CAAP;AACA,SAAOO,GAAP;AACD;AAED;;;;;;;;;;AAQA,SAAS6E,gBAAT,CAA2BrF,MAA3B,EAAmC;AACjC,MAAIkF,IAAI,GAAGlF,MAAM,CAAC0B,WAAlB;AACA,MAAIyD,MAAM,GAAGD,IAAI,CAAChF,MAAlB;AACA,MAAIA,MAAM,GAAGF,MAAM,CAACuB,UAAP,GAAoBvB,MAAM,CAACwB,SAA3B,GAAuC,CAApD;AACA,MAAIvB,MAAM,GAAGD,MAAM,CAACuB,UAAP,GAAoBvB,MAAM,CAACyB,cAAxC;AACAzB,EAAAA,MAAM,CAACC,MAAP,GAAgBA,MAAhB;;AACA,MAAIA,MAAM,IAAI,CAAd,EAAiB;AACf,QAAIkF,MAAM,KAAK,CAAf,EAAkB;AAChB,aAAOD,IAAI,CAAC,CAAD,CAAJ,CAAQrE,KAAR,CAAcb,MAAM,CAACwB,SAArB,EAAgC0D,IAAI,CAAC,CAAD,CAAJ,CAAQhF,MAAR,GAAiBD,MAAjB,GAA0B,CAA1D,CAAP;AACD;;AACDkF,IAAAA,MAAM;AACNlF,IAAAA,MAAM,GAAGiF,IAAI,CAACA,IAAI,CAAChF,MAAL,GAAc,CAAf,CAAJ,CAAsBA,MAAtB,GAA+BD,MAAxC;AACD;;AACD6E,EAAAA,YAAY,CAAC5E,MAAD,CAAZ;AACA,MAAIQ,KAAK,GAAGnB,YAAZ;AACA2F,EAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQI,IAAR,CAAajG,UAAb,EAAyBqB,KAAzB,EAAgCV,MAAM,CAACwB,SAAvC,EAAkD0D,IAAI,CAAC,CAAD,CAAJ,CAAQhF,MAA1D;AACAX,EAAAA,YAAY,IAAI2F,IAAI,CAAC,CAAD,CAAJ,CAAQhF,MAAR,GAAiBF,MAAM,CAACwB,SAAxC;;AACA,OAAK,IAAIoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuC,MAAM,GAAG,CAA7B,EAAgCvC,CAAC,EAAjC,EAAqC;AACnCsC,IAAAA,IAAI,CAACtC,CAAD,CAAJ,CAAQ0C,IAAR,CAAajG,UAAb,EAAyBE,YAAzB;AACAA,IAAAA,YAAY,IAAI2F,IAAI,CAACtC,CAAD,CAAJ,CAAQ1C,MAAxB;AACD;;AACDgF,EAAAA,IAAI,CAACtC,CAAD,CAAJ,CAAQ0C,IAAR,CAAajG,UAAb,EAAyBE,YAAzB,EAAuC,CAAvC,EAA0CU,MAAM,GAAG,CAAnD;AACAV,EAAAA,YAAY,IAAIU,MAAM,GAAG,CAAzB;AACA,SAAOZ,UAAU,CAACwB,KAAX,CAAiBH,KAAjB,EAAwBnB,YAAxB,CAAP;AACD;AAED;;;;;;;AAKAoE,qBAAqB,CAACW,SAAtB,CAAgCiB,OAAhC,GAA0C,SAASA,OAAT,CAAkBpF,MAAlB,EAA0B;AAClE,MAAI,KAAKA,MAAL,KAAgB,IAApB,EAA0B;AACxB,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKF,MAAL,GAAc,CAAd;AACD,GAHD,MAGO,IAAI,KAAKsB,UAAL,KAAoB,CAAxB,EAA2B;AAChC,QAAIiE,SAAS,GAAG,KAAKrF,MAAL,CAAYD,MAA5B;AACA,QAAIuF,eAAe,GAAGD,SAAS,GAAG,KAAKvF,MAAvC;AACA,QAAIyF,SAAS,GAAGpG,WAAW,CAACmG,eAAe,GAAGtF,MAAM,CAACD,MAA1B,CAA3B;AACA,SAAKC,MAAL,CAAYmF,IAAZ,CAAiBI,SAAjB,EAA4B,CAA5B,EAA+B,KAAKzF,MAApC,EAA4CuF,SAA5C;AACArF,IAAAA,MAAM,CAACmF,IAAP,CAAYI,SAAZ,EAAuBD,eAAvB,EAAwC,CAAxC,EAA2CtF,MAAM,CAACD,MAAlD;AACA,SAAKC,MAAL,GAAcuF,SAAd;AACA,SAAKzF,MAAL,GAAc,CAAd;;AACA,QAAI,KAAKsC,UAAL,CAAgBrC,MAApB,EAA4B;AAC1B,UAAIyF,GAAG,GAAGlD,gBAAgB,CAAC,IAAD,CAA1B;;AACA,UAAI,CAACkD,GAAL,EAAU;AACR;AACD;;AACD,WAAKpC,WAAL,CAAiBoC,GAAjB;AACD;AACF,GAfM,MAeA,IAAI,KAAKlE,cAAL,GAAsBtB,MAAM,CAACD,MAA7B,IAAuC,KAAKqB,UAAhD,EAA4D;AACjE,SAAKG,WAAL,CAAiBC,IAAjB,CAAsBxB,MAAtB;AACA,QAAIuC,GAAG,GAAG,KAAK9B,mBAAL,GAA2ByE,gBAAgB,CAAC,IAAD,CAA3C,GAAoDJ,gBAAgB,CAAC,IAAD,CAA9E;AACA,SAAK1D,UAAL,GAAkB,CAAlB;AACA,SAAKG,WAAL,GAAmB,EAAnB;AACA,SAAKvB,MAAL,GAAcA,MAAd;;AACA,QAAI,KAAKoC,UAAL,CAAgBrC,MAApB,EAA4B;AAC1B,WAAKqC,UAAL,CAAgB,CAAhB,EAAmB,KAAKC,QAAL,CAAc,CAAd,GAAnB,IAAyCE,GAAzC;AACAA,MAAAA,GAAG,GAAGD,gBAAgB,CAAC,IAAD,CAAtB;;AACA,UAAI,CAACC,GAAL,EAAU;AACR;AACD;AACF;;AACD,SAAKa,WAAL,CAAiBb,GAAjB;AACD,GAdM,MAcA;AACL,SAAKhB,WAAL,CAAiBC,IAAjB,CAAsBxB,MAAtB;AACA,SAAKsB,cAAL,IAAuBtB,MAAM,CAACD,MAA9B;AACA;AACD;;AAED,SAAO,KAAKD,MAAL,GAAc,KAAKE,MAAL,CAAYD,MAAjC,EAAyC;AACvC,QAAID,MAAM,GAAG,KAAKA,MAAlB;AACA,QAAI+C,IAAI,GAAG,KAAK7C,MAAL,CAAY,KAAKF,MAAL,EAAZ,CAAX;AACA,QAAI6C,QAAQ,GAAGC,SAAS,CAAC,IAAD,EAAOC,IAAP,CAAxB;;AACA,QAAIF,QAAQ,KAAK5B,SAAjB,EAA4B;AAC1B,UAAI,CAAC,KAAKqB,UAAL,CAAgBrC,MAArB,EAA6B;AAC3B,aAAKD,MAAL,GAAcA,MAAd;AACD;;AACD;AACD;;AAED,QAAI+C,IAAI,KAAK,EAAb,EAAiB;AACf,WAAKM,WAAL,CAAiBR,QAAjB;AACD,KAFD,MAEO;AACL,WAAKS,WAAL,CAAiBT,QAAjB;AACD;AACF;;AAED,OAAK3C,MAAL,GAAc,IAAd;AACD,CA1DD;;AA4DAyF,MAAM,CAACC,OAAP,GAAiBlC,qBAAjB","sourcesContent":["'use strict'\n\nvar StringDecoder = require('string_decoder').StringDecoder\nvar decoder = new StringDecoder()\nvar ReplyError = require('./replyError')\nvar ParserError = require('./parserError')\nvar bufferPool = bufferAlloc(32 * 1024)\nvar bufferOffset = 0\nvar interval = null\nvar counter = 0\nvar notDecreased = 0\nvar isModern = typeof Buffer.allocUnsafe === 'function'\n\n/**\n * For backwards compatibility\n * @param len\n * @returns {Buffer}\n */\n\nfunction bufferAlloc (len) {\n  return isModern ? Buffer.allocUnsafe(len) : new Buffer(len)\n}\n\n/**\n * Used for lengths and numbers only, faster perf on arrays / bulks\n * @param parser\n * @returns {*}\n */\nfunction parseSimpleNumbers (parser) {\n  var offset = parser.offset\n  var length = parser.buffer.length - 1\n  var number = 0\n  var sign = 1\n\n  if (parser.buffer[offset] === 45) {\n    sign = -1\n    offset++\n  }\n\n  while (offset < length) {\n    var c1 = parser.buffer[offset++]\n    if (c1 === 13) { // \\r\\n\n      parser.offset = offset + 1\n      return sign * number\n    }\n    number = (number * 10) + (c1 - 48)\n  }\n}\n\n/**\n * Used for integer numbers in case of the returnNumbers option\n *\n * The maximimum possible integer to use is: Math.floor(Number.MAX_SAFE_INTEGER / 10)\n * Staying in a SMI Math.floor((Math.pow(2, 32) / 10) - 1) is even more efficient though\n *\n * @param parser\n * @returns {*}\n */\nfunction parseStringNumbers (parser) {\n  var offset = parser.offset\n  var length = parser.buffer.length - 1\n  var number = 0\n  var res = ''\n\n  if (parser.buffer[offset] === 45) {\n    res += '-'\n    offset++\n  }\n\n  while (offset < length) {\n    var c1 = parser.buffer[offset++]\n    if (c1 === 13) { // \\r\\n\n      parser.offset = offset + 1\n      if (number !== 0) {\n        res += number\n      }\n      return res\n    } else if (number > 429496728) {\n      res += (number * 10) + (c1 - 48)\n      number = 0\n    } else if (c1 === 48 && number === 0) {\n      res += 0\n    } else {\n      number = (number * 10) + (c1 - 48)\n    }\n  }\n}\n\n/**\n * Returns a string or buffer of the provided offset start and\n * end ranges. Checks `optionReturnBuffers`.\n *\n * If returnBuffers is active, all return values are returned as buffers besides numbers and errors\n *\n * @param parser\n * @param start\n * @param end\n * @returns {*}\n */\nfunction convertBufferRange (parser, start, end) {\n  parser.offset = end + 2\n  if (parser.optionReturnBuffers === true) {\n    return parser.buffer.slice(start, end)\n  }\n\n  return parser.buffer.toString('utf-8', start, end)\n}\n\n/**\n * Parse a '+' redis simple string response but forward the offsets\n * onto convertBufferRange to generate a string.\n * @param parser\n * @returns {*}\n */\nfunction parseSimpleString (parser) {\n  var start = parser.offset\n  var offset = start\n  var buffer = parser.buffer\n  var length = buffer.length - 1\n\n  while (offset < length) {\n    if (buffer[offset++] === 13) { // \\r\\n\n      return convertBufferRange(parser, start, offset - 1)\n    }\n  }\n}\n\n/**\n * Returns the string length via parseSimpleNumbers\n * @param parser\n * @returns {*}\n */\nfunction parseLength (parser) {\n  var string = parseSimpleNumbers(parser)\n  if (string !== undefined) {\n    return string\n  }\n}\n\n/**\n * Parse a ':' redis integer response\n *\n * If stringNumbers is activated the parser always returns numbers as string\n * This is important for big numbers (number > Math.pow(2, 53)) as js numbers\n * are 64bit floating point numbers with reduced precision\n *\n * @param parser\n * @returns {*}\n */\nfunction parseInteger (parser) {\n  if (parser.optionStringNumbers) {\n    return parseStringNumbers(parser)\n  }\n  return parseSimpleNumbers(parser)\n}\n\n/**\n * Parse a '$' redis bulk string response\n * @param parser\n * @returns {*}\n */\nfunction parseBulkString (parser) {\n  var length = parseLength(parser)\n  if (length === undefined) {\n    return\n  }\n  if (length === -1) {\n    return null\n  }\n  var offsetEnd = parser.offset + length\n  if (offsetEnd + 2 > parser.buffer.length) {\n    parser.bigStrSize = offsetEnd + 2\n    parser.bigOffset = parser.offset\n    parser.totalChunkSize = parser.buffer.length\n    parser.bufferCache.push(parser.buffer)\n    return\n  }\n\n  return convertBufferRange(parser, parser.offset, offsetEnd)\n}\n\n/**\n * Parse a '-' redis error response\n * @param parser\n * @returns {Error}\n */\nfunction parseError (parser) {\n  var string = parseSimpleString(parser)\n  if (string !== undefined) {\n    if (parser.optionReturnBuffers === true) {\n      string = string.toString()\n    }\n    return new ReplyError(string)\n  }\n}\n\n/**\n * Parsing error handler, resets parser buffer\n * @param parser\n * @param error\n */\nfunction handleError (parser, error) {\n  parser.buffer = null\n  parser.returnFatalError(error)\n}\n\n/**\n * Parse a '*' redis array response\n * @param parser\n * @returns {*}\n */\nfunction parseArray (parser) {\n  var length = parseLength(parser)\n  if (length === undefined) {\n    return\n  }\n  if (length === -1) {\n    return null\n  }\n  var responses = new Array(length)\n  return parseArrayElements(parser, responses, 0)\n}\n\n/**\n * Push a partly parsed array to the stack\n *\n * @param parser\n * @param elem\n * @param i\n * @returns {undefined}\n */\nfunction pushArrayCache (parser, elem, pos) {\n  parser.arrayCache.push(elem)\n  parser.arrayPos.push(pos)\n}\n\n/**\n * Parse chunked redis array response\n * @param parser\n * @returns {*}\n */\nfunction parseArrayChunks (parser) {\n  var tmp = parser.arrayCache.pop()\n  var pos = parser.arrayPos.pop()\n  if (parser.arrayCache.length) {\n    var res = parseArrayChunks(parser)\n    if (!res) {\n      pushArrayCache(parser, tmp, pos)\n      return\n    }\n    tmp[pos++] = res\n  }\n  return parseArrayElements(parser, tmp, pos)\n}\n\n/**\n * Parse redis array response elements\n * @param parser\n * @param responses\n * @param i\n * @returns {*}\n */\nfunction parseArrayElements (parser, responses, i) {\n  var bufferLength = parser.buffer.length\n  while (i < responses.length) {\n    var offset = parser.offset\n    if (parser.offset >= bufferLength) {\n      pushArrayCache(parser, responses, i)\n      return\n    }\n    var response = parseType(parser, parser.buffer[parser.offset++])\n    if (response === undefined) {\n      if (!parser.arrayCache.length) {\n        parser.offset = offset\n      }\n      pushArrayCache(parser, responses, i)\n      return\n    }\n    responses[i] = response\n    i++\n  }\n\n  return responses\n}\n\n/**\n * Called the appropriate parser for the specified type.\n * @param parser\n * @param type\n * @returns {*}\n */\nfunction parseType (parser, type) {\n  switch (type) {\n    case 36: // $\n      return parseBulkString(parser)\n    case 58: // :\n      return parseInteger(parser)\n    case 43: // +\n      return parseSimpleString(parser)\n    case 42: // *\n      return parseArray(parser)\n    case 45: // -\n      return parseError(parser)\n    default:\n      return handleError(parser, new ParserError(\n        'Protocol error, got ' + JSON.stringify(String.fromCharCode(type)) + ' as reply type byte',\n        JSON.stringify(parser.buffer),\n        parser.offset\n      ))\n  }\n}\n\n// All allowed options including their typeof value\nvar optionTypes = {\n  returnError: 'function',\n  returnFatalError: 'function',\n  returnReply: 'function',\n  returnBuffers: 'boolean',\n  stringNumbers: 'boolean',\n  name: 'string'\n}\n\n/**\n * Javascript Redis Parser\n * @param options\n * @constructor\n */\nfunction JavascriptRedisParser (options) {\n  if (!(this instanceof JavascriptRedisParser)) {\n    return new JavascriptRedisParser(options)\n  }\n  if (!options || !options.returnError || !options.returnReply) {\n    throw new TypeError('Please provide all return functions while initiating the parser')\n  }\n  for (var key in options) {\n    // eslint-disable-next-line valid-typeof\n    if (optionTypes.hasOwnProperty(key) && typeof options[key] !== optionTypes[key]) {\n      throw new TypeError('The options argument contains the property \"' + key + '\" that is either unknown or of a wrong type')\n    }\n  }\n  if (options.name === 'hiredis') {\n    /* istanbul ignore next: hiredis is only supported for legacy usage */\n    try {\n      var Hiredis = require('./hiredis')\n      console.error(new TypeError('Using hiredis is discouraged. Please use the faster JS parser by removing the name option.').stack.replace('Error', 'Warning'))\n      return new Hiredis(options)\n    } catch (e) {\n      console.error(new TypeError('Hiredis is not installed. Please remove the `name` option. The (faster) JS parser is used instead.').stack.replace('Error', 'Warning'))\n    }\n  }\n  this.optionReturnBuffers = !!options.returnBuffers\n  this.optionStringNumbers = !!options.stringNumbers\n  this.returnError = options.returnError\n  this.returnFatalError = options.returnFatalError || options.returnError\n  this.returnReply = options.returnReply\n  this.name = 'javascript'\n  this.reset()\n}\n\n/**\n * Reset the parser values to the initial state\n *\n * @returns {undefined}\n */\nJavascriptRedisParser.prototype.reset = function () {\n  this.offset = 0\n  this.buffer = null\n  this.bigStrSize = 0\n  this.bigOffset = 0\n  this.totalChunkSize = 0\n  this.bufferCache = []\n  this.arrayCache = []\n  this.arrayPos = []\n}\n\n/**\n * Set the returnBuffers option\n *\n * @param returnBuffers\n * @returns {undefined}\n */\nJavascriptRedisParser.prototype.setReturnBuffers = function (returnBuffers) {\n  if (typeof returnBuffers !== 'boolean') {\n    throw new TypeError('The returnBuffers argument has to be a boolean')\n  }\n  this.optionReturnBuffers = returnBuffers\n}\n\n/**\n * Set the stringNumbers option\n *\n * @param stringNumbers\n * @returns {undefined}\n */\nJavascriptRedisParser.prototype.setStringNumbers = function (stringNumbers) {\n  if (typeof stringNumbers !== 'boolean') {\n    throw new TypeError('The stringNumbers argument has to be a boolean')\n  }\n  this.optionStringNumbers = stringNumbers\n}\n\n/**\n * Decrease the bufferPool size over time\n * @returns {undefined}\n */\nfunction decreaseBufferPool () {\n  if (bufferPool.length > 50 * 1024) {\n    // Balance between increasing and decreasing the bufferPool\n    if (counter === 1 || notDecreased > counter * 2) {\n      // Decrease the bufferPool by 10% by removing the first 10% of the current pool\n      var sliceLength = Math.floor(bufferPool.length / 10)\n      if (bufferOffset <= sliceLength) {\n        bufferOffset = 0\n      } else {\n        bufferOffset -= sliceLength\n      }\n      bufferPool = bufferPool.slice(sliceLength, bufferPool.length)\n    } else {\n      notDecreased++\n      counter--\n    }\n  } else {\n    clearInterval(interval)\n    counter = 0\n    notDecreased = 0\n    interval = null\n  }\n}\n\n/**\n * Check if the requested size fits in the current bufferPool.\n * If it does not, reset and increase the bufferPool accordingly.\n *\n * @param length\n * @returns {undefined}\n */\nfunction resizeBuffer (length) {\n  if (bufferPool.length < length + bufferOffset) {\n    var multiplier = length > 1024 * 1024 * 75 ? 2 : 3\n    if (bufferOffset > 1024 * 1024 * 111) {\n      bufferOffset = 1024 * 1024 * 50\n    }\n    bufferPool = bufferAlloc(length * multiplier + bufferOffset)\n    bufferOffset = 0\n    counter++\n    if (interval === null) {\n      interval = setInterval(decreaseBufferPool, 50)\n    }\n  }\n}\n\n/**\n * Concat a bulk string containing multiple chunks\n *\n * Notes:\n * 1) The first chunk might contain the whole bulk string including the \\r\n * 2) We are only safe to fully add up elements that are neither the first nor any of the last two elements\n *\n * @param parser\n * @returns {String}\n */\nfunction concatBulkString (parser) {\n  var list = parser.bufferCache\n  var chunks = list.length\n  var offset = parser.bigStrSize - parser.totalChunkSize\n  parser.offset = offset\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].toString('utf8', parser.bigOffset, list[0].length + offset - 2)\n    }\n    chunks--\n    offset = list[list.length - 2].length + offset\n  }\n  var res = decoder.write(list[0].slice(parser.bigOffset))\n  for (var i = 1; i < chunks - 1; i++) {\n    res += decoder.write(list[i])\n  }\n  res += decoder.end(list[i].slice(0, offset - 2))\n  return res\n}\n\n/**\n * Concat the collected chunks from parser.bufferCache.\n *\n * Increases the bufferPool size beforehand if necessary.\n *\n * @param parser\n * @returns {Buffer}\n */\nfunction concatBulkBuffer (parser) {\n  var list = parser.bufferCache\n  var chunks = list.length\n  var length = parser.bigStrSize - parser.bigOffset - 2\n  var offset = parser.bigStrSize - parser.totalChunkSize\n  parser.offset = offset\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].slice(parser.bigOffset, list[0].length + offset - 2)\n    }\n    chunks--\n    offset = list[list.length - 2].length + offset\n  }\n  resizeBuffer(length)\n  var start = bufferOffset\n  list[0].copy(bufferPool, start, parser.bigOffset, list[0].length)\n  bufferOffset += list[0].length - parser.bigOffset\n  for (var i = 1; i < chunks - 1; i++) {\n    list[i].copy(bufferPool, bufferOffset)\n    bufferOffset += list[i].length\n  }\n  list[i].copy(bufferPool, bufferOffset, 0, offset - 2)\n  bufferOffset += offset - 2\n  return bufferPool.slice(start, bufferOffset)\n}\n\n/**\n * Parse the redis buffer\n * @param buffer\n * @returns {undefined}\n */\nJavascriptRedisParser.prototype.execute = function execute (buffer) {\n  if (this.buffer === null) {\n    this.buffer = buffer\n    this.offset = 0\n  } else if (this.bigStrSize === 0) {\n    var oldLength = this.buffer.length\n    var remainingLength = oldLength - this.offset\n    var newBuffer = bufferAlloc(remainingLength + buffer.length)\n    this.buffer.copy(newBuffer, 0, this.offset, oldLength)\n    buffer.copy(newBuffer, remainingLength, 0, buffer.length)\n    this.buffer = newBuffer\n    this.offset = 0\n    if (this.arrayCache.length) {\n      var arr = parseArrayChunks(this)\n      if (!arr) {\n        return\n      }\n      this.returnReply(arr)\n    }\n  } else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {\n    this.bufferCache.push(buffer)\n    var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this)\n    this.bigStrSize = 0\n    this.bufferCache = []\n    this.buffer = buffer\n    if (this.arrayCache.length) {\n      this.arrayCache[0][this.arrayPos[0]++] = tmp\n      tmp = parseArrayChunks(this)\n      if (!tmp) {\n        return\n      }\n    }\n    this.returnReply(tmp)\n  } else {\n    this.bufferCache.push(buffer)\n    this.totalChunkSize += buffer.length\n    return\n  }\n\n  while (this.offset < this.buffer.length) {\n    var offset = this.offset\n    var type = this.buffer[this.offset++]\n    var response = parseType(this, type)\n    if (response === undefined) {\n      if (!this.arrayCache.length) {\n        this.offset = offset\n      }\n      return\n    }\n\n    if (type === 45) {\n      this.returnError(response)\n    } else {\n      this.returnReply(response)\n    }\n  }\n\n  this.buffer = null\n}\n\nmodule.exports = JavascriptRedisParser\n"]},"metadata":{},"sourceType":"script"}