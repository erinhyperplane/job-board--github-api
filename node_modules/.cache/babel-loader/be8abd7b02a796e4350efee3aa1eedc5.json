{"ast":null,"code":"'use strict';\n\nvar net = require('net');\n\nvar tls = require('tls');\n\nvar util = require('util');\n\nvar utils = require('./lib/utils');\n\nvar Command = require('./lib/command');\n\nvar Queue = require('double-ended-queue');\n\nvar errorClasses = require('./lib/customErrors');\n\nvar EventEmitter = require('events');\n\nvar Parser = require('redis-parser');\n\nvar commands = require('redis-commands');\n\nvar debug = require('./lib/debug');\n\nvar unifyOptions = require('./lib/createClient');\n\nvar SUBSCRIBE_COMMANDS = {\n  subscribe: true,\n  unsubscribe: true,\n  psubscribe: true,\n  punsubscribe: true\n}; // Newer Node.js versions > 0.10 return the EventEmitter right away and using .EventEmitter was deprecated\n\nif (typeof EventEmitter !== 'function') {\n  EventEmitter = EventEmitter.EventEmitter;\n}\n\nfunction noop() {}\n\nfunction handle_detect_buffers_reply(reply, command, buffer_args) {\n  if (buffer_args === false || this.message_buffers) {\n    // If detect_buffers option was specified, then the reply from the parser will be a buffer.\n    // If this command did not use Buffer arguments, then convert the reply to Strings here.\n    reply = utils.reply_to_strings(reply);\n  }\n\n  if (command === 'hgetall') {\n    reply = utils.reply_to_object(reply);\n  }\n\n  return reply;\n}\n\nexports.debug_mode = /\\bredis\\b/i.test(process.env.NODE_DEBUG); // Attention: The second parameter might be removed at will and is not officially supported.\n// Do not rely on this\n\nfunction RedisClient(options, stream) {\n  // Copy the options so they are not mutated\n  options = utils.clone(options);\n  EventEmitter.call(this);\n  var cnx_options = {};\n  var self = this;\n  /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n\n  for (var tls_option in options.tls) {\n    cnx_options[tls_option] = options.tls[tls_option]; // Copy the tls options into the general options to make sure the address is set right\n\n    if (tls_option === 'port' || tls_option === 'host' || tls_option === 'path' || tls_option === 'family') {\n      options[tls_option] = options.tls[tls_option];\n    }\n  }\n\n  if (stream) {\n    // The stream from the outside is used so no connection from this side is triggered but from the server this client should talk to\n    // Reconnect etc won't work with this. This requires monkey patching to work, so it is not officially supported\n    options.stream = stream;\n    this.address = '\"Private stream\"';\n  } else if (options.path) {\n    cnx_options.path = options.path;\n    this.address = options.path;\n  } else {\n    cnx_options.port = +options.port || 6379;\n    cnx_options.host = options.host || '127.0.0.1';\n    cnx_options.family = !options.family && net.isIP(cnx_options.host) || (options.family === 'IPv6' ? 6 : 4);\n    this.address = cnx_options.host + ':' + cnx_options.port;\n  } // Warn on misusing deprecated functions\n\n\n  if (typeof options.retry_strategy === 'function') {\n    if ('max_attempts' in options) {\n      self.warn('WARNING: You activated the retry_strategy and max_attempts at the same time. This is not possible and max_attempts will be ignored.'); // Do not print deprecation warnings twice\n\n      delete options.max_attempts;\n    }\n\n    if ('retry_max_delay' in options) {\n      self.warn('WARNING: You activated the retry_strategy and retry_max_delay at the same time. This is not possible and retry_max_delay will be ignored.'); // Do not print deprecation warnings twice\n\n      delete options.retry_max_delay;\n    }\n  }\n\n  this.connection_options = cnx_options;\n  this.connection_id = RedisClient.connection_id++;\n  this.connected = false;\n  this.ready = false;\n\n  if (options.socket_nodelay === undefined) {\n    options.socket_nodelay = true;\n  } else if (!options.socket_nodelay) {\n    // Only warn users with this set to false\n    self.warn('socket_nodelay is deprecated and will be removed in v.3.0.0.\\n' + 'Setting socket_nodelay to false likely results in a reduced throughput. Please use .batch for pipelining instead.\\n' + 'If you are sure you rely on the NAGLE-algorithm you can activate it by calling client.stream.setNoDelay(false) instead.');\n  }\n\n  if (options.socket_keepalive === undefined) {\n    options.socket_keepalive = true;\n  }\n\n  for (var command in options.rename_commands) {\n    options.rename_commands[command.toLowerCase()] = options.rename_commands[command];\n  }\n\n  options.return_buffers = !!options.return_buffers;\n  options.detect_buffers = !!options.detect_buffers; // Override the detect_buffers setting if return_buffers is active and print a warning\n\n  if (options.return_buffers && options.detect_buffers) {\n    self.warn('WARNING: You activated return_buffers and detect_buffers at the same time. The return value is always going to be a buffer.');\n    options.detect_buffers = false;\n  }\n\n  if (options.detect_buffers) {\n    // We only need to look at the arguments if we do not know what we have to return\n    this.handle_reply = handle_detect_buffers_reply;\n  }\n\n  this.should_buffer = false;\n  this.max_attempts = options.max_attempts | 0;\n\n  if ('max_attempts' in options) {\n    self.warn('max_attempts is deprecated and will be removed in v.3.0.0.\\n' + 'To reduce the number of options and to improve the reconnection handling please use the new `retry_strategy` option instead.\\n' + 'This replaces the max_attempts and retry_max_delay option.');\n  }\n\n  this.command_queue = new Queue(); // Holds sent commands to de-pipeline them\n\n  this.offline_queue = new Queue(); // Holds commands issued but not able to be sent\n\n  this.pipeline_queue = new Queue(); // Holds all pipelined commands\n  // ATTENTION: connect_timeout should change in v.3.0 so it does not count towards ending reconnection attempts after x seconds\n  // This should be done by the retry_strategy. Instead it should only be the timeout for connecting to redis\n\n  this.connect_timeout = +options.connect_timeout || 3600000; // 60 * 60 * 1000 ms\n\n  this.enable_offline_queue = options.enable_offline_queue === false ? false : true;\n  this.retry_max_delay = +options.retry_max_delay || null;\n\n  if ('retry_max_delay' in options) {\n    self.warn('retry_max_delay is deprecated and will be removed in v.3.0.0.\\n' + 'To reduce the amount of options and the improve the reconnection handling please use the new `retry_strategy` option instead.\\n' + 'This replaces the max_attempts and retry_max_delay option.');\n  }\n\n  this.initialize_retry_vars();\n  this.pub_sub_mode = 0;\n  this.subscription_set = {};\n  this.monitoring = false;\n  this.message_buffers = false;\n  this.closing = false;\n  this.server_info = {};\n  this.auth_pass = options.auth_pass || options.password;\n  this.selected_db = options.db; // Save the selected db here, used when reconnecting\n\n  this.old_state = null;\n  this.fire_strings = true; // Determine if strings or buffers should be written to the stream\n\n  this.pipeline = false;\n  this.sub_commands_left = 0;\n  this.times_connected = 0;\n  this.buffers = options.return_buffers || options.detect_buffers;\n  this.options = options;\n  this.reply = 'ON'; // Returning replies is the default\n\n  this.create_stream(); // The listeners will not be attached right away, so let's print the deprecation message while the listener is attached\n\n  this.on('newListener', function (event) {\n    if (event === 'idle') {\n      this.warn('The idle event listener is deprecated and will likely be removed in v.3.0.0.\\n' + 'If you rely on this feature please open a new ticket in node_redis with your use case');\n    } else if (event === 'drain') {\n      this.warn('The drain event listener is deprecated and will be removed in v.3.0.0.\\n' + 'If you want to keep on listening to this event please listen to the stream drain event directly.');\n    } else if ((event === 'message_buffer' || event === 'pmessage_buffer' || event === 'messageBuffer' || event === 'pmessageBuffer') && !this.buffers && !this.message_buffers) {\n      if (this.reply_parser.name !== 'javascript') {\n        return this.warn('You attached the \"' + event + '\" listener without the returnBuffers option set to true.\\n' + 'Please use the JavaScript parser or set the returnBuffers option to true to return buffers.');\n      }\n\n      this.reply_parser.optionReturnBuffers = true;\n      this.message_buffers = true;\n      this.handle_reply = handle_detect_buffers_reply;\n    }\n  });\n}\n\nutil.inherits(RedisClient, EventEmitter);\nRedisClient.connection_id = 0;\n\nfunction create_parser(self) {\n  return new Parser({\n    returnReply: function (data) {\n      self.return_reply(data);\n    },\n    returnError: function (err) {\n      // Return a ReplyError to indicate Redis returned an error\n      self.return_error(err);\n    },\n    returnFatalError: function (err) {\n      // Error out all fired commands. Otherwise they might rely on faulty data. We have to reconnect to get in a working state again\n      // Note: the execution order is important. First flush and emit, then create the stream\n      err.message += '. Please report this.';\n      self.ready = false;\n      self.flush_and_error({\n        message: 'Fatal error encountert. Command aborted.',\n        code: 'NR_FATAL'\n      }, {\n        error: err,\n        queues: ['command_queue']\n      });\n      self.emit('error', err);\n      self.create_stream();\n    },\n    returnBuffers: self.buffers || self.message_buffers,\n    name: self.options.parser || 'javascript',\n    stringNumbers: self.options.string_numbers || false\n  });\n}\n/******************************************************************************\n\n    All functions in here are internal besides the RedisClient constructor\n    and the exported functions. Don't rely on them as they will be private\n    functions in node_redis v.3\n\n******************************************************************************/\n// Attention: the function name \"create_stream\" should not be changed, as other libraries need this to mock the stream (e.g. fakeredis)\n\n\nRedisClient.prototype.create_stream = function () {\n  var self = this; // Init parser\n\n  this.reply_parser = create_parser(this);\n\n  if (this.options.stream) {\n    // Only add the listeners once in case of a reconnect try (that won't work)\n    if (this.stream) {\n      return;\n    }\n\n    this.stream = this.options.stream;\n  } else {\n    // On a reconnect destroy the former stream and retry\n    if (this.stream) {\n      this.stream.removeAllListeners();\n      this.stream.destroy();\n    }\n    /* istanbul ignore if: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n\n\n    if (this.options.tls) {\n      this.stream = tls.connect(this.connection_options);\n    } else {\n      this.stream = net.createConnection(this.connection_options);\n    }\n  }\n\n  if (this.options.connect_timeout) {\n    this.stream.setTimeout(this.connect_timeout, function () {\n      // Note: This is only tested if a internet connection is established\n      self.retry_totaltime = self.connect_timeout;\n      self.connection_gone('timeout');\n    });\n  }\n  /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n\n\n  var connect_event = this.options.tls ? 'secureConnect' : 'connect';\n  this.stream.once(connect_event, function () {\n    this.removeAllListeners('timeout');\n    self.times_connected++;\n    self.on_connect();\n  });\n  this.stream.on('data', function (buffer_from_socket) {\n    // The buffer_from_socket.toString() has a significant impact on big chunks and therefore this should only be used if necessary\n    debug('Net read ' + self.address + ' id ' + self.connection_id); // + ': ' + buffer_from_socket.toString());\n\n    self.reply_parser.execute(buffer_from_socket);\n    self.emit_idle();\n  });\n  this.stream.on('error', function (err) {\n    self.on_error(err);\n  });\n  /* istanbul ignore next: difficult to test and not important as long as we keep this listener */\n\n  this.stream.on('clientError', function (err) {\n    debug('clientError occured');\n    self.on_error(err);\n  });\n  this.stream.once('close', function (hadError) {\n    self.connection_gone('close');\n  });\n  this.stream.once('end', function () {\n    self.connection_gone('end');\n  });\n  this.stream.on('drain', function () {\n    self.drain();\n  });\n\n  if (this.options.socket_nodelay) {\n    this.stream.setNoDelay();\n  } // Fire the command before redis is connected to be sure it's the first fired command\n\n\n  if (this.auth_pass !== undefined) {\n    this.ready = true; // Fail silently as we might not be able to connect\n\n    this.auth(this.auth_pass, function (err) {\n      if (err && err.code !== 'UNCERTAIN_STATE') {\n        self.emit('error', err);\n      }\n    });\n    this.ready = false;\n  }\n};\n\nRedisClient.prototype.handle_reply = function (reply, command) {\n  if (command === 'hgetall') {\n    reply = utils.reply_to_object(reply);\n  }\n\n  return reply;\n};\n\nRedisClient.prototype.cork = noop;\nRedisClient.prototype.uncork = noop;\n\nRedisClient.prototype.initialize_retry_vars = function () {\n  this.retry_timer = null;\n  this.retry_totaltime = 0;\n  this.retry_delay = 200;\n  this.retry_backoff = 1.7;\n  this.attempts = 1;\n};\n\nRedisClient.prototype.warn = function (msg) {\n  var self = this; // Warn on the next tick. Otherwise no event listener can be added\n  // for warnings that are emitted in the redis client constructor\n\n  process.nextTick(function () {\n    if (self.listeners('warning').length !== 0) {\n      self.emit('warning', msg);\n    } else {\n      console.warn('node_redis:', msg);\n    }\n  });\n}; // Flush provided queues, erroring any items with a callback first\n\n\nRedisClient.prototype.flush_and_error = function (error_attributes, options) {\n  options = options || {};\n  var aggregated_errors = [];\n  var queue_names = options.queues || ['command_queue', 'offline_queue']; // Flush the command_queue first to keep the order intakt\n\n  for (var i = 0; i < queue_names.length; i++) {\n    // If the command was fired it might have been processed so far\n    if (queue_names[i] === 'command_queue') {\n      error_attributes.message += ' It might have been processed.';\n    } else {\n      // As the command_queue is flushed first, remove this for the offline queue\n      error_attributes.message = error_attributes.message.replace(' It might have been processed.', '');\n    } // Don't flush everything from the queue\n\n\n    for (var command_obj = this[queue_names[i]].shift(); command_obj; command_obj = this[queue_names[i]].shift()) {\n      var err = new errorClasses.AbortError(error_attributes);\n\n      if (command_obj.error) {\n        err.stack = err.stack + command_obj.error.stack.replace(/^Error.*?\\n/, '\\n');\n      }\n\n      err.command = command_obj.command.toUpperCase();\n\n      if (command_obj.args && command_obj.args.length) {\n        err.args = command_obj.args;\n      }\n\n      if (options.error) {\n        err.origin = options.error;\n      }\n\n      if (typeof command_obj.callback === 'function') {\n        command_obj.callback(err);\n      } else {\n        aggregated_errors.push(err);\n      }\n    }\n  } // Currently this would be a breaking change, therefore it's only emitted in debug_mode\n\n\n  if (exports.debug_mode && aggregated_errors.length) {\n    var error;\n\n    if (aggregated_errors.length === 1) {\n      error = aggregated_errors[0];\n    } else {\n      error_attributes.message = error_attributes.message.replace('It', 'They').replace(/command/i, '$&s');\n      error = new errorClasses.AggregateError(error_attributes);\n      error.errors = aggregated_errors;\n    }\n\n    this.emit('error', error);\n  }\n};\n\nRedisClient.prototype.on_error = function (err) {\n  if (this.closing) {\n    return;\n  }\n\n  err.message = 'Redis connection to ' + this.address + ' failed - ' + err.message;\n  debug(err.message);\n  this.connected = false;\n  this.ready = false; // Only emit the error if the retry_stategy option is not set\n\n  if (!this.options.retry_strategy) {\n    this.emit('error', err);\n  } // 'error' events get turned into exceptions if they aren't listened for. If the user handled this error\n  // then we should try to reconnect.\n\n\n  this.connection_gone('error', err);\n};\n\nRedisClient.prototype.on_connect = function () {\n  debug('Stream connected ' + this.address + ' id ' + this.connection_id);\n  this.connected = true;\n  this.ready = false;\n  this.emitted_end = false;\n  this.stream.setKeepAlive(this.options.socket_keepalive);\n  this.stream.setTimeout(0);\n  this.emit('connect');\n  this.initialize_retry_vars();\n\n  if (this.options.no_ready_check) {\n    this.on_ready();\n  } else {\n    this.ready_check();\n  }\n};\n\nRedisClient.prototype.on_ready = function () {\n  var self = this;\n  debug('on_ready called ' + this.address + ' id ' + this.connection_id);\n  this.ready = true;\n\n  this.cork = function () {\n    self.pipeline = true;\n\n    if (self.stream.cork) {\n      self.stream.cork();\n    }\n  };\n\n  this.uncork = function () {\n    if (self.fire_strings) {\n      self.write_strings();\n    } else {\n      self.write_buffers();\n    }\n\n    self.pipeline = false;\n    self.fire_strings = true;\n\n    if (self.stream.uncork) {\n      // TODO: Consider using next tick here. See https://github.com/NodeRedis/node_redis/issues/1033\n      self.stream.uncork();\n    }\n  }; // Restore modal commands from previous connection. The order of the commands is important\n\n\n  if (this.selected_db !== undefined) {\n    this.internal_send_command(new Command('select', [this.selected_db]));\n  }\n\n  if (this.monitoring) {\n    // Monitor has to be fired before pub sub commands\n    this.internal_send_command(new Command('monitor', []));\n  }\n\n  var callback_count = Object.keys(this.subscription_set).length;\n\n  if (!this.options.disable_resubscribing && callback_count) {\n    // only emit 'ready' when all subscriptions were made again\n    // TODO: Remove the countdown for ready here. This is not coherent with all other modes and should therefore not be handled special\n    // We know we are ready as soon as all commands were fired\n    var callback = function () {\n      callback_count--;\n\n      if (callback_count === 0) {\n        self.emit('ready');\n      }\n    };\n\n    debug('Sending pub/sub on_ready commands');\n\n    for (var key in this.subscription_set) {\n      var command = key.slice(0, key.indexOf('_'));\n      var args = this.subscription_set[key];\n      this[command]([args], callback);\n    }\n\n    this.send_offline_queue();\n    return;\n  }\n\n  this.send_offline_queue();\n  this.emit('ready');\n};\n\nRedisClient.prototype.on_info_cmd = function (err, res) {\n  if (err) {\n    if (err.message === \"ERR unknown command 'info'\") {\n      this.on_ready();\n      return;\n    }\n\n    err.message = 'Ready check failed: ' + err.message;\n    this.emit('error', err);\n    return;\n  }\n  /* istanbul ignore if: some servers might not respond with any info data. This is just a safety check that is difficult to test */\n\n\n  if (!res) {\n    debug('The info command returned without any data.');\n    this.on_ready();\n    return;\n  }\n\n  if (!this.server_info.loading || this.server_info.loading === '0') {\n    // If the master_link_status exists but the link is not up, try again after 50 ms\n    if (this.server_info.master_link_status && this.server_info.master_link_status !== 'up') {\n      this.server_info.loading_eta_seconds = 0.05;\n    } else {\n      // Eta loading should change\n      debug('Redis server ready.');\n      this.on_ready();\n      return;\n    }\n  }\n\n  var retry_time = +this.server_info.loading_eta_seconds * 1000;\n\n  if (retry_time > 1000) {\n    retry_time = 1000;\n  }\n\n  debug('Redis server still loading, trying again in ' + retry_time);\n  setTimeout(function (self) {\n    self.ready_check();\n  }, retry_time, this);\n};\n\nRedisClient.prototype.ready_check = function () {\n  var self = this;\n  debug('Checking server ready state...'); // Always fire this info command as first command even if other commands are already queued up\n\n  this.ready = true;\n  this.info(function (err, res) {\n    self.on_info_cmd(err, res);\n  });\n  this.ready = false;\n};\n\nRedisClient.prototype.send_offline_queue = function () {\n  for (var command_obj = this.offline_queue.shift(); command_obj; command_obj = this.offline_queue.shift()) {\n    debug('Sending offline command: ' + command_obj.command);\n    this.internal_send_command(command_obj);\n  }\n\n  this.drain();\n};\n\nvar retry_connection = function (self, error) {\n  debug('Retrying connection...');\n  var reconnect_params = {\n    delay: self.retry_delay,\n    attempt: self.attempts,\n    error: error\n  };\n\n  if (self.options.camel_case) {\n    reconnect_params.totalRetryTime = self.retry_totaltime;\n    reconnect_params.timesConnected = self.times_connected;\n  } else {\n    reconnect_params.total_retry_time = self.retry_totaltime;\n    reconnect_params.times_connected = self.times_connected;\n  }\n\n  self.emit('reconnecting', reconnect_params);\n  self.retry_totaltime += self.retry_delay;\n  self.attempts += 1;\n  self.retry_delay = Math.round(self.retry_delay * self.retry_backoff);\n  self.create_stream();\n  self.retry_timer = null;\n};\n\nRedisClient.prototype.connection_gone = function (why, error) {\n  // If a retry is already in progress, just let that happen\n  if (this.retry_timer) {\n    return;\n  }\n\n  error = error || null;\n  debug('Redis connection is gone from ' + why + ' event.');\n  this.connected = false;\n  this.ready = false; // Deactivate cork to work with the offline queue\n\n  this.cork = noop;\n  this.uncork = noop;\n  this.pipeline = false;\n  this.pub_sub_mode = 0; // since we are collapsing end and close, users don't expect to be called twice\n\n  if (!this.emitted_end) {\n    this.emit('end');\n    this.emitted_end = true;\n  } // If this is a requested shutdown, then don't retry\n\n\n  if (this.closing) {\n    debug('Connection ended by quit / end command, not retrying.');\n    this.flush_and_error({\n      message: 'Stream connection ended and command aborted.',\n      code: 'NR_CLOSED'\n    }, {\n      error: error\n    });\n    return;\n  }\n\n  if (typeof this.options.retry_strategy === 'function') {\n    var retry_params = {\n      attempt: this.attempts,\n      error: error\n    };\n\n    if (this.options.camel_case) {\n      retry_params.totalRetryTime = this.retry_totaltime;\n      retry_params.timesConnected = this.times_connected;\n    } else {\n      retry_params.total_retry_time = this.retry_totaltime;\n      retry_params.times_connected = this.times_connected;\n    }\n\n    this.retry_delay = this.options.retry_strategy(retry_params);\n\n    if (typeof this.retry_delay !== 'number') {\n      // Pass individual error through\n      if (this.retry_delay instanceof Error) {\n        error = this.retry_delay;\n      }\n\n      this.flush_and_error({\n        message: 'Stream connection ended and command aborted.',\n        code: 'NR_CLOSED'\n      }, {\n        error: error\n      });\n      this.end(false);\n      return;\n    }\n  }\n\n  if (this.max_attempts !== 0 && this.attempts >= this.max_attempts || this.retry_totaltime >= this.connect_timeout) {\n    var message = 'Redis connection in broken state: ';\n\n    if (this.retry_totaltime >= this.connect_timeout) {\n      message += 'connection timeout exceeded.';\n    } else {\n      message += 'maximum connection attempts exceeded.';\n    }\n\n    this.flush_and_error({\n      message: message,\n      code: 'CONNECTION_BROKEN'\n    }, {\n      error: error\n    });\n    var err = new Error(message);\n    err.code = 'CONNECTION_BROKEN';\n\n    if (error) {\n      err.origin = error;\n    }\n\n    this.emit('error', err);\n    this.end(false);\n    return;\n  } // Retry commands after a reconnect instead of throwing an error. Use this with caution\n\n\n  if (this.options.retry_unfulfilled_commands) {\n    this.offline_queue.unshift.apply(this.offline_queue, this.command_queue.toArray());\n    this.command_queue.clear();\n  } else if (this.command_queue.length !== 0) {\n    this.flush_and_error({\n      message: 'Redis connection lost and command aborted.',\n      code: 'UNCERTAIN_STATE'\n    }, {\n      error: error,\n      queues: ['command_queue']\n    });\n  }\n\n  if (this.retry_max_delay !== null && this.retry_delay > this.retry_max_delay) {\n    this.retry_delay = this.retry_max_delay;\n  } else if (this.retry_totaltime + this.retry_delay > this.connect_timeout) {\n    // Do not exceed the maximum\n    this.retry_delay = this.connect_timeout - this.retry_totaltime;\n  }\n\n  debug('Retry connection in ' + this.retry_delay + ' ms');\n  this.retry_timer = setTimeout(retry_connection, this.retry_delay, this, error);\n};\n\nRedisClient.prototype.return_error = function (err) {\n  var command_obj = this.command_queue.shift();\n\n  if (command_obj.error) {\n    err.stack = command_obj.error.stack.replace(/^Error.*?\\n/, 'ReplyError: ' + err.message + '\\n');\n  }\n\n  err.command = command_obj.command.toUpperCase();\n\n  if (command_obj.args && command_obj.args.length) {\n    err.args = command_obj.args;\n  } // Count down pub sub mode if in entering modus\n\n\n  if (this.pub_sub_mode > 1) {\n    this.pub_sub_mode--;\n  }\n\n  var match = err.message.match(utils.err_code); // LUA script could return user errors that don't behave like all other errors!\n\n  if (match) {\n    err.code = match[1];\n  }\n\n  utils.callback_or_emit(this, command_obj.callback, err);\n};\n\nRedisClient.prototype.drain = function () {\n  this.emit('drain');\n  this.should_buffer = false;\n};\n\nRedisClient.prototype.emit_idle = function () {\n  if (this.command_queue.length === 0 && this.pub_sub_mode === 0) {\n    this.emit('idle');\n  }\n};\n\nfunction normal_reply(self, reply) {\n  var command_obj = self.command_queue.shift();\n\n  if (typeof command_obj.callback === 'function') {\n    if (command_obj.command !== 'exec') {\n      reply = self.handle_reply(reply, command_obj.command, command_obj.buffer_args);\n    }\n\n    command_obj.callback(null, reply);\n  } else {\n    debug('No callback for reply');\n  }\n}\n\nfunction subscribe_unsubscribe(self, reply, type) {\n  // Subscribe commands take an optional callback and also emit an event, but only the _last_ response is included in the callback\n  // The pub sub commands return each argument in a separate return value and have to be handled that way\n  var command_obj = self.command_queue.get(0);\n  var buffer = self.options.return_buffers || self.options.detect_buffers && command_obj.buffer_args;\n  var channel = buffer || reply[1] === null ? reply[1] : reply[1].toString();\n  var count = +reply[2]; // Return the channel counter as number no matter if `string_numbers` is activated or not\n\n  debug(type, channel); // Emit first, then return the callback\n\n  if (channel !== null) {\n    // Do not emit or \"unsubscribe\" something if there was no channel to unsubscribe from\n    self.emit(type, channel, count);\n\n    if (type === 'subscribe' || type === 'psubscribe') {\n      self.subscription_set[type + '_' + channel] = channel;\n    } else {\n      type = type === 'unsubscribe' ? 'subscribe' : 'psubscribe'; // Make types consistent\n\n      delete self.subscription_set[type + '_' + channel];\n    }\n  }\n\n  if (command_obj.args.length === 1 || self.sub_commands_left === 1 || command_obj.args.length === 0 && (count === 0 || channel === null)) {\n    if (count === 0) {\n      // unsubscribed from all channels\n      var running_command;\n      var i = 1;\n      self.pub_sub_mode = 0; // Deactivating pub sub mode\n      // This should be a rare case and therefore handling it this way should be good performance wise for the general case\n\n      while (running_command = self.command_queue.get(i)) {\n        if (SUBSCRIBE_COMMANDS[running_command.command]) {\n          self.pub_sub_mode = i; // Entering pub sub mode again\n\n          break;\n        }\n\n        i++;\n      }\n    }\n\n    self.command_queue.shift();\n\n    if (typeof command_obj.callback === 'function') {\n      // TODO: The current return value is pretty useless.\n      // Evaluate to change this in v.3 to return all subscribed / unsubscribed channels in an array including the number of channels subscribed too\n      command_obj.callback(null, channel);\n    }\n\n    self.sub_commands_left = 0;\n  } else {\n    if (self.sub_commands_left !== 0) {\n      self.sub_commands_left--;\n    } else {\n      self.sub_commands_left = command_obj.args.length ? command_obj.args.length - 1 : count;\n    }\n  }\n}\n\nfunction return_pub_sub(self, reply) {\n  var type = reply[0].toString();\n\n  if (type === 'message') {\n    // channel, message\n    if (!self.options.return_buffers || self.message_buffers) {\n      // backwards compatible. Refactor this in v.3 to always return a string on the normal emitter\n      self.emit('message', reply[1].toString(), reply[2].toString());\n      self.emit('message_buffer', reply[1], reply[2]);\n      self.emit('messageBuffer', reply[1], reply[2]);\n    } else {\n      self.emit('message', reply[1], reply[2]);\n    }\n  } else if (type === 'pmessage') {\n    // pattern, channel, message\n    if (!self.options.return_buffers || self.message_buffers) {\n      // backwards compatible. Refactor this in v.3 to always return a string on the normal emitter\n      self.emit('pmessage', reply[1].toString(), reply[2].toString(), reply[3].toString());\n      self.emit('pmessage_buffer', reply[1], reply[2], reply[3]);\n      self.emit('pmessageBuffer', reply[1], reply[2], reply[3]);\n    } else {\n      self.emit('pmessage', reply[1], reply[2], reply[3]);\n    }\n  } else {\n    subscribe_unsubscribe(self, reply, type);\n  }\n}\n\nRedisClient.prototype.return_reply = function (reply) {\n  if (this.monitoring) {\n    var replyStr;\n\n    if (this.buffers && Buffer.isBuffer(reply)) {\n      replyStr = reply.toString();\n    } else {\n      replyStr = reply;\n    } // If in monitor mode, all normal commands are still working and we only want to emit the streamlined commands\n\n\n    if (typeof replyStr === 'string' && utils.monitor_regex.test(replyStr)) {\n      var timestamp = replyStr.slice(0, replyStr.indexOf(' '));\n      var args = replyStr.slice(replyStr.indexOf('\"') + 1, -1).split('\" \"').map(function (elem) {\n        return elem.replace(/\\\\\"/g, '\"');\n      });\n      this.emit('monitor', timestamp, args, replyStr);\n      return;\n    }\n  }\n\n  if (this.pub_sub_mode === 0) {\n    normal_reply(this, reply);\n  } else if (this.pub_sub_mode !== 1) {\n    this.pub_sub_mode--;\n    normal_reply(this, reply);\n  } else if (!(reply instanceof Array) || reply.length <= 2) {\n    // Only PING and QUIT are allowed in this context besides the pub sub commands\n    // Ping replies with ['pong', null|value] and quit with 'OK'\n    normal_reply(this, reply);\n  } else {\n    return_pub_sub(this, reply);\n  }\n};\n\nfunction handle_offline_command(self, command_obj) {\n  var command = command_obj.command;\n  var err, msg;\n\n  if (self.closing || !self.enable_offline_queue) {\n    command = command.toUpperCase();\n\n    if (!self.closing) {\n      if (self.stream.writable) {\n        msg = 'The connection is not yet established and the offline queue is deactivated.';\n      } else {\n        msg = 'Stream not writeable.';\n      }\n    } else {\n      msg = 'The connection is already closed.';\n    }\n\n    err = new errorClasses.AbortError({\n      message: command + \" can't be processed. \" + msg,\n      code: 'NR_CLOSED',\n      command: command\n    });\n\n    if (command_obj.args.length) {\n      err.args = command_obj.args;\n    }\n\n    utils.reply_in_order(self, command_obj.callback, err);\n  } else {\n    debug('Queueing ' + command + ' for next server connection.');\n    self.offline_queue.push(command_obj);\n  }\n\n  self.should_buffer = true;\n} // Do not call internal_send_command directly, if you are not absolutly certain it handles everything properly\n// e.g. monitor / info does not work with internal_send_command only\n\n\nRedisClient.prototype.internal_send_command = function (command_obj) {\n  var arg, prefix_keys;\n  var i = 0;\n  var command_str = '';\n  var args = command_obj.args;\n  var command = command_obj.command;\n  var len = args.length;\n  var big_data = false;\n  var args_copy = new Array(len);\n\n  if (process.domain && command_obj.callback) {\n    command_obj.callback = process.domain.bind(command_obj.callback);\n  }\n\n  if (this.ready === false || this.stream.writable === false) {\n    // Handle offline commands right away\n    handle_offline_command(this, command_obj);\n    return false; // Indicate buffering\n  }\n\n  for (i = 0; i < len; i += 1) {\n    if (typeof args[i] === 'string') {\n      // 30000 seemed to be a good value to switch to buffers after testing and checking the pros and cons\n      if (args[i].length > 30000) {\n        big_data = true;\n        args_copy[i] = new Buffer(args[i], 'utf8');\n      } else {\n        args_copy[i] = args[i];\n      }\n    } else if (typeof args[i] === 'object') {\n      // Checking for object instead of Buffer.isBuffer helps us finding data types that we can't handle properly\n      if (args[i] instanceof Date) {\n        // Accept dates as valid input\n        args_copy[i] = args[i].toString();\n      } else if (args[i] === null) {\n        this.warn('Deprecated: The ' + command.toUpperCase() + ' command contains a \"null\" argument.\\n' + 'This is converted to a \"null\" string now and will return an error from v.3.0 on.\\n' + 'Please handle this in your code to make sure everything works as you intended it to.');\n        args_copy[i] = 'null'; // Backwards compatible :/\n      } else if (Buffer.isBuffer(args[i])) {\n        args_copy[i] = args[i];\n        command_obj.buffer_args = true;\n        big_data = true;\n      } else {\n        this.warn('Deprecated: The ' + command.toUpperCase() + ' command contains a argument of type ' + args[i].constructor.name + '.\\n' + 'This is converted to \"' + args[i].toString() + '\" by using .toString() now and will return an error from v.3.0 on.\\n' + 'Please handle this in your code to make sure everything works as you intended it to.');\n        args_copy[i] = args[i].toString(); // Backwards compatible :/\n      }\n    } else if (typeof args[i] === 'undefined') {\n      this.warn('Deprecated: The ' + command.toUpperCase() + ' command contains a \"undefined\" argument.\\n' + 'This is converted to a \"undefined\" string now and will return an error from v.3.0 on.\\n' + 'Please handle this in your code to make sure everything works as you intended it to.');\n      args_copy[i] = 'undefined'; // Backwards compatible :/\n    } else {\n      // Seems like numbers are converted fast using string concatenation\n      args_copy[i] = '' + args[i];\n    }\n  }\n\n  if (this.options.prefix) {\n    prefix_keys = commands.getKeyIndexes(command, args_copy);\n\n    for (i = prefix_keys.pop(); i !== undefined; i = prefix_keys.pop()) {\n      args_copy[i] = this.options.prefix + args_copy[i];\n    }\n  }\n\n  if (this.options.rename_commands && this.options.rename_commands[command]) {\n    command = this.options.rename_commands[command];\n  } // Always use 'Multi bulk commands', but if passed any Buffer args, then do multiple writes, one for each arg.\n  // This means that using Buffers in commands is going to be slower, so use Strings if you don't already have a Buffer.\n\n\n  command_str = '*' + (len + 1) + '\\r\\n$' + command.length + '\\r\\n' + command + '\\r\\n';\n\n  if (big_data === false) {\n    // Build up a string and send entire command in one write\n    for (i = 0; i < len; i += 1) {\n      arg = args_copy[i];\n      command_str += '$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n';\n    }\n\n    debug('Send ' + this.address + ' id ' + this.connection_id + ': ' + command_str);\n    this.write(command_str);\n  } else {\n    debug('Send command (' + command_str + ') has Buffer arguments');\n    this.fire_strings = false;\n    this.write(command_str);\n\n    for (i = 0; i < len; i += 1) {\n      arg = args_copy[i];\n\n      if (typeof arg === 'string') {\n        this.write('$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n');\n      } else {\n        // buffer\n        this.write('$' + arg.length + '\\r\\n');\n        this.write(arg);\n        this.write('\\r\\n');\n      }\n\n      debug('send_command: buffer send ' + arg.length + ' bytes');\n    }\n  }\n\n  if (command_obj.call_on_write) {\n    command_obj.call_on_write();\n  } // Handle `CLIENT REPLY ON|OFF|SKIP`\n  // This has to be checked after call_on_write\n\n  /* istanbul ignore else: TODO: Remove this as soon as we test Redis 3.2 on travis */\n\n\n  if (this.reply === 'ON') {\n    this.command_queue.push(command_obj);\n  } else {\n    // Do not expect a reply\n    // Does this work in combination with the pub sub mode?\n    if (command_obj.callback) {\n      utils.reply_in_order(this, command_obj.callback, null, undefined, this.command_queue);\n    }\n\n    if (this.reply === 'SKIP') {\n      this.reply = 'SKIP_ONE_MORE';\n    } else if (this.reply === 'SKIP_ONE_MORE') {\n      this.reply = 'ON';\n    }\n  }\n\n  return !this.should_buffer;\n};\n\nRedisClient.prototype.write_strings = function () {\n  var str = '';\n\n  for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n    // Write to stream if the string is bigger than 4mb. The biggest string may be Math.pow(2, 28) - 15 chars long\n    if (str.length + command.length > 4 * 1024 * 1024) {\n      this.should_buffer = !this.stream.write(str);\n      str = '';\n    }\n\n    str += command;\n  }\n\n  if (str !== '') {\n    this.should_buffer = !this.stream.write(str);\n  }\n};\n\nRedisClient.prototype.write_buffers = function () {\n  for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n    this.should_buffer = !this.stream.write(command);\n  }\n};\n\nRedisClient.prototype.write = function (data) {\n  if (this.pipeline === false) {\n    this.should_buffer = !this.stream.write(data);\n    return;\n  }\n\n  this.pipeline_queue.push(data);\n};\n\nObject.defineProperty(exports, 'debugMode', {\n  get: function () {\n    return this.debug_mode;\n  },\n  set: function (val) {\n    this.debug_mode = val;\n  }\n}); // Don't officially expose the command_queue directly but only the length as read only variable\n\nObject.defineProperty(RedisClient.prototype, 'command_queue_length', {\n  get: function () {\n    return this.command_queue.length;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'offline_queue_length', {\n  get: function () {\n    return this.offline_queue.length;\n  }\n}); // Add support for camelCase by adding read only properties to the client\n// All known exposed snake_case variables are added here\n\nObject.defineProperty(RedisClient.prototype, 'retryDelay', {\n  get: function () {\n    return this.retry_delay;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'retryBackoff', {\n  get: function () {\n    return this.retry_backoff;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'commandQueueLength', {\n  get: function () {\n    return this.command_queue.length;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'offlineQueueLength', {\n  get: function () {\n    return this.offline_queue.length;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'shouldBuffer', {\n  get: function () {\n    return this.should_buffer;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'connectionId', {\n  get: function () {\n    return this.connection_id;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'serverInfo', {\n  get: function () {\n    return this.server_info;\n  }\n});\n\nexports.createClient = function () {\n  return new RedisClient(unifyOptions.apply(null, arguments));\n};\n\nexports.RedisClient = RedisClient;\nexports.print = utils.print;\nexports.Multi = require('./lib/multi');\nexports.AbortError = errorClasses.AbortError;\nexports.RedisError = Parser.RedisError;\nexports.ParserError = Parser.ParserError;\nexports.ReplyError = Parser.ReplyError;\nexports.AggregateError = errorClasses.AggregateError; // Add all redis commands / node_redis api to the client\n\nrequire('./lib/individualCommands');\n\nrequire('./lib/extendedApi'); //enables adding new commands (for modules and new commands)\n\n\nexports.addCommand = exports.add_command = require('./lib/commands');","map":{"version":3,"sources":["/Users/erinx/code/hyperplaneReact/road-to-react/js-job-board-diy/node_modules/redis/index.js"],"names":["net","require","tls","util","utils","Command","Queue","errorClasses","EventEmitter","Parser","commands","debug","unifyOptions","SUBSCRIBE_COMMANDS","subscribe","unsubscribe","psubscribe","punsubscribe","noop","handle_detect_buffers_reply","reply","command","buffer_args","message_buffers","reply_to_strings","reply_to_object","exports","debug_mode","test","process","env","NODE_DEBUG","RedisClient","options","stream","clone","call","cnx_options","self","tls_option","address","path","port","host","family","isIP","retry_strategy","warn","max_attempts","retry_max_delay","connection_options","connection_id","connected","ready","socket_nodelay","undefined","socket_keepalive","rename_commands","toLowerCase","return_buffers","detect_buffers","handle_reply","should_buffer","command_queue","offline_queue","pipeline_queue","connect_timeout","enable_offline_queue","initialize_retry_vars","pub_sub_mode","subscription_set","monitoring","closing","server_info","auth_pass","password","selected_db","db","old_state","fire_strings","pipeline","sub_commands_left","times_connected","buffers","create_stream","on","event","reply_parser","name","optionReturnBuffers","inherits","create_parser","returnReply","data","return_reply","returnError","err","return_error","returnFatalError","message","flush_and_error","code","error","queues","emit","returnBuffers","parser","stringNumbers","string_numbers","prototype","removeAllListeners","destroy","connect","createConnection","setTimeout","retry_totaltime","connection_gone","connect_event","once","on_connect","buffer_from_socket","execute","emit_idle","on_error","hadError","drain","setNoDelay","auth","cork","uncork","retry_timer","retry_delay","retry_backoff","attempts","msg","nextTick","listeners","length","console","error_attributes","aggregated_errors","queue_names","i","replace","command_obj","shift","AbortError","stack","toUpperCase","args","origin","callback","push","AggregateError","errors","emitted_end","setKeepAlive","no_ready_check","on_ready","ready_check","write_strings","write_buffers","internal_send_command","callback_count","Object","keys","disable_resubscribing","key","slice","indexOf","send_offline_queue","on_info_cmd","res","loading","master_link_status","loading_eta_seconds","retry_time","info","retry_connection","reconnect_params","delay","attempt","camel_case","totalRetryTime","timesConnected","total_retry_time","Math","round","why","retry_params","Error","end","retry_unfulfilled_commands","unshift","apply","toArray","clear","match","err_code","callback_or_emit","normal_reply","subscribe_unsubscribe","type","get","buffer","channel","toString","count","running_command","return_pub_sub","replyStr","Buffer","isBuffer","monitor_regex","timestamp","split","map","elem","Array","handle_offline_command","writable","reply_in_order","arg","prefix_keys","command_str","len","big_data","args_copy","domain","bind","Date","constructor","prefix","getKeyIndexes","pop","byteLength","write","call_on_write","str","defineProperty","set","val","createClient","arguments","print","Multi","RedisError","ParserError","ReplyError","addCommand","add_command"],"mappings":"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","sourcesContent":["'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar util = require('util');\nvar utils = require('./lib/utils');\nvar Command = require('./lib/command');\nvar Queue = require('double-ended-queue');\nvar errorClasses = require('./lib/customErrors');\nvar EventEmitter = require('events');\nvar Parser = require('redis-parser');\nvar commands = require('redis-commands');\nvar debug = require('./lib/debug');\nvar unifyOptions = require('./lib/createClient');\nvar SUBSCRIBE_COMMANDS = {\n    subscribe: true,\n    unsubscribe: true,\n    psubscribe: true,\n    punsubscribe: true\n};\n\n// Newer Node.js versions > 0.10 return the EventEmitter right away and using .EventEmitter was deprecated\nif (typeof EventEmitter !== 'function') {\n    EventEmitter = EventEmitter.EventEmitter;\n}\n\nfunction noop () {}\n\nfunction handle_detect_buffers_reply (reply, command, buffer_args) {\n    if (buffer_args === false || this.message_buffers) {\n        // If detect_buffers option was specified, then the reply from the parser will be a buffer.\n        // If this command did not use Buffer arguments, then convert the reply to Strings here.\n        reply = utils.reply_to_strings(reply);\n    }\n\n    if (command === 'hgetall') {\n        reply = utils.reply_to_object(reply);\n    }\n    return reply;\n}\n\nexports.debug_mode = /\\bredis\\b/i.test(process.env.NODE_DEBUG);\n\n// Attention: The second parameter might be removed at will and is not officially supported.\n// Do not rely on this\nfunction RedisClient (options, stream) {\n    // Copy the options so they are not mutated\n    options = utils.clone(options);\n    EventEmitter.call(this);\n    var cnx_options = {};\n    var self = this;\n    /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n    for (var tls_option in options.tls) {\n        cnx_options[tls_option] = options.tls[tls_option];\n        // Copy the tls options into the general options to make sure the address is set right\n        if (tls_option === 'port' || tls_option === 'host' || tls_option === 'path' || tls_option === 'family') {\n            options[tls_option] = options.tls[tls_option];\n        }\n    }\n    if (stream) {\n        // The stream from the outside is used so no connection from this side is triggered but from the server this client should talk to\n        // Reconnect etc won't work with this. This requires monkey patching to work, so it is not officially supported\n        options.stream = stream;\n        this.address = '\"Private stream\"';\n    } else if (options.path) {\n        cnx_options.path = options.path;\n        this.address = options.path;\n    } else {\n        cnx_options.port = +options.port || 6379;\n        cnx_options.host = options.host || '127.0.0.1';\n        cnx_options.family = (!options.family && net.isIP(cnx_options.host)) || (options.family === 'IPv6' ? 6 : 4);\n        this.address = cnx_options.host + ':' + cnx_options.port;\n    }\n    // Warn on misusing deprecated functions\n    if (typeof options.retry_strategy === 'function') {\n        if ('max_attempts' in options) {\n            self.warn('WARNING: You activated the retry_strategy and max_attempts at the same time. This is not possible and max_attempts will be ignored.');\n            // Do not print deprecation warnings twice\n            delete options.max_attempts;\n        }\n        if ('retry_max_delay' in options) {\n            self.warn('WARNING: You activated the retry_strategy and retry_max_delay at the same time. This is not possible and retry_max_delay will be ignored.');\n            // Do not print deprecation warnings twice\n            delete options.retry_max_delay;\n        }\n    }\n\n    this.connection_options = cnx_options;\n    this.connection_id = RedisClient.connection_id++;\n    this.connected = false;\n    this.ready = false;\n    if (options.socket_nodelay === undefined) {\n        options.socket_nodelay = true;\n    } else if (!options.socket_nodelay) { // Only warn users with this set to false\n        self.warn(\n            'socket_nodelay is deprecated and will be removed in v.3.0.0.\\n' +\n            'Setting socket_nodelay to false likely results in a reduced throughput. Please use .batch for pipelining instead.\\n' +\n            'If you are sure you rely on the NAGLE-algorithm you can activate it by calling client.stream.setNoDelay(false) instead.'\n        );\n    }\n    if (options.socket_keepalive === undefined) {\n        options.socket_keepalive = true;\n    }\n    for (var command in options.rename_commands) {\n        options.rename_commands[command.toLowerCase()] = options.rename_commands[command];\n    }\n    options.return_buffers = !!options.return_buffers;\n    options.detect_buffers = !!options.detect_buffers;\n    // Override the detect_buffers setting if return_buffers is active and print a warning\n    if (options.return_buffers && options.detect_buffers) {\n        self.warn('WARNING: You activated return_buffers and detect_buffers at the same time. The return value is always going to be a buffer.');\n        options.detect_buffers = false;\n    }\n    if (options.detect_buffers) {\n        // We only need to look at the arguments if we do not know what we have to return\n        this.handle_reply = handle_detect_buffers_reply;\n    }\n    this.should_buffer = false;\n    this.max_attempts = options.max_attempts | 0;\n    if ('max_attempts' in options) {\n        self.warn(\n            'max_attempts is deprecated and will be removed in v.3.0.0.\\n' +\n            'To reduce the number of options and to improve the reconnection handling please use the new `retry_strategy` option instead.\\n' +\n            'This replaces the max_attempts and retry_max_delay option.'\n        );\n    }\n    this.command_queue = new Queue(); // Holds sent commands to de-pipeline them\n    this.offline_queue = new Queue(); // Holds commands issued but not able to be sent\n    this.pipeline_queue = new Queue(); // Holds all pipelined commands\n    // ATTENTION: connect_timeout should change in v.3.0 so it does not count towards ending reconnection attempts after x seconds\n    // This should be done by the retry_strategy. Instead it should only be the timeout for connecting to redis\n    this.connect_timeout = +options.connect_timeout || 3600000; // 60 * 60 * 1000 ms\n    this.enable_offline_queue = options.enable_offline_queue === false ? false : true;\n    this.retry_max_delay = +options.retry_max_delay || null;\n    if ('retry_max_delay' in options) {\n        self.warn(\n            'retry_max_delay is deprecated and will be removed in v.3.0.0.\\n' +\n            'To reduce the amount of options and the improve the reconnection handling please use the new `retry_strategy` option instead.\\n' +\n            'This replaces the max_attempts and retry_max_delay option.'\n        );\n    }\n    this.initialize_retry_vars();\n    this.pub_sub_mode = 0;\n    this.subscription_set = {};\n    this.monitoring = false;\n    this.message_buffers = false;\n    this.closing = false;\n    this.server_info = {};\n    this.auth_pass = options.auth_pass || options.password;\n    this.selected_db = options.db; // Save the selected db here, used when reconnecting\n    this.old_state = null;\n    this.fire_strings = true; // Determine if strings or buffers should be written to the stream\n    this.pipeline = false;\n    this.sub_commands_left = 0;\n    this.times_connected = 0;\n    this.buffers = options.return_buffers || options.detect_buffers;\n    this.options = options;\n    this.reply = 'ON'; // Returning replies is the default\n    this.create_stream();\n    // The listeners will not be attached right away, so let's print the deprecation message while the listener is attached\n    this.on('newListener', function (event) {\n        if (event === 'idle') {\n            this.warn(\n                'The idle event listener is deprecated and will likely be removed in v.3.0.0.\\n' +\n                'If you rely on this feature please open a new ticket in node_redis with your use case'\n            );\n        } else if (event === 'drain') {\n            this.warn(\n                'The drain event listener is deprecated and will be removed in v.3.0.0.\\n' +\n                'If you want to keep on listening to this event please listen to the stream drain event directly.'\n            );\n        } else if ((event === 'message_buffer' || event === 'pmessage_buffer' || event === 'messageBuffer' || event === 'pmessageBuffer') && !this.buffers && !this.message_buffers) {\n            if (this.reply_parser.name !== 'javascript') {\n                return this.warn(\n                    'You attached the \"' + event + '\" listener without the returnBuffers option set to true.\\n' +\n                    'Please use the JavaScript parser or set the returnBuffers option to true to return buffers.'\n                );\n            }\n            this.reply_parser.optionReturnBuffers = true;\n            this.message_buffers = true;\n            this.handle_reply = handle_detect_buffers_reply;\n        }\n    });\n}\nutil.inherits(RedisClient, EventEmitter);\n\nRedisClient.connection_id = 0;\n\nfunction create_parser (self) {\n    return new Parser({\n        returnReply: function (data) {\n            self.return_reply(data);\n        },\n        returnError: function (err) {\n            // Return a ReplyError to indicate Redis returned an error\n            self.return_error(err);\n        },\n        returnFatalError: function (err) {\n            // Error out all fired commands. Otherwise they might rely on faulty data. We have to reconnect to get in a working state again\n            // Note: the execution order is important. First flush and emit, then create the stream\n            err.message += '. Please report this.';\n            self.ready = false;\n            self.flush_and_error({\n                message: 'Fatal error encountert. Command aborted.',\n                code: 'NR_FATAL'\n            }, {\n                error: err,\n                queues: ['command_queue']\n            });\n            self.emit('error', err);\n            self.create_stream();\n        },\n        returnBuffers: self.buffers || self.message_buffers,\n        name: self.options.parser || 'javascript',\n        stringNumbers: self.options.string_numbers || false\n    });\n}\n\n/******************************************************************************\n\n    All functions in here are internal besides the RedisClient constructor\n    and the exported functions. Don't rely on them as they will be private\n    functions in node_redis v.3\n\n******************************************************************************/\n\n// Attention: the function name \"create_stream\" should not be changed, as other libraries need this to mock the stream (e.g. fakeredis)\nRedisClient.prototype.create_stream = function () {\n    var self = this;\n\n    // Init parser\n    this.reply_parser = create_parser(this);\n\n    if (this.options.stream) {\n        // Only add the listeners once in case of a reconnect try (that won't work)\n        if (this.stream) {\n            return;\n        }\n        this.stream = this.options.stream;\n    } else {\n        // On a reconnect destroy the former stream and retry\n        if (this.stream) {\n            this.stream.removeAllListeners();\n            this.stream.destroy();\n        }\n\n        /* istanbul ignore if: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n        if (this.options.tls) {\n            this.stream = tls.connect(this.connection_options);\n        } else {\n            this.stream = net.createConnection(this.connection_options);\n        }\n    }\n\n    if (this.options.connect_timeout) {\n        this.stream.setTimeout(this.connect_timeout, function () {\n            // Note: This is only tested if a internet connection is established\n            self.retry_totaltime = self.connect_timeout;\n            self.connection_gone('timeout');\n        });\n    }\n\n    /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n    var connect_event = this.options.tls ? 'secureConnect' : 'connect';\n    this.stream.once(connect_event, function () {\n        this.removeAllListeners('timeout');\n        self.times_connected++;\n        self.on_connect();\n    });\n\n    this.stream.on('data', function (buffer_from_socket) {\n        // The buffer_from_socket.toString() has a significant impact on big chunks and therefore this should only be used if necessary\n        debug('Net read ' + self.address + ' id ' + self.connection_id); // + ': ' + buffer_from_socket.toString());\n        self.reply_parser.execute(buffer_from_socket);\n        self.emit_idle();\n    });\n\n    this.stream.on('error', function (err) {\n        self.on_error(err);\n    });\n\n    /* istanbul ignore next: difficult to test and not important as long as we keep this listener */\n    this.stream.on('clientError', function (err) {\n        debug('clientError occured');\n        self.on_error(err);\n    });\n\n    this.stream.once('close', function (hadError) {\n        self.connection_gone('close');\n    });\n\n    this.stream.once('end', function () {\n        self.connection_gone('end');\n    });\n\n    this.stream.on('drain', function () {\n        self.drain();\n    });\n\n    if (this.options.socket_nodelay) {\n        this.stream.setNoDelay();\n    }\n\n    // Fire the command before redis is connected to be sure it's the first fired command\n    if (this.auth_pass !== undefined) {\n        this.ready = true;\n        // Fail silently as we might not be able to connect\n        this.auth(this.auth_pass, function (err) {\n            if (err && err.code !== 'UNCERTAIN_STATE') {\n                self.emit('error', err);\n            }\n        });\n        this.ready = false;\n    }\n};\n\nRedisClient.prototype.handle_reply = function (reply, command) {\n    if (command === 'hgetall') {\n        reply = utils.reply_to_object(reply);\n    }\n    return reply;\n};\n\nRedisClient.prototype.cork = noop;\nRedisClient.prototype.uncork = noop;\n\nRedisClient.prototype.initialize_retry_vars = function () {\n    this.retry_timer = null;\n    this.retry_totaltime = 0;\n    this.retry_delay = 200;\n    this.retry_backoff = 1.7;\n    this.attempts = 1;\n};\n\nRedisClient.prototype.warn = function (msg) {\n    var self = this;\n    // Warn on the next tick. Otherwise no event listener can be added\n    // for warnings that are emitted in the redis client constructor\n    process.nextTick(function () {\n        if (self.listeners('warning').length !== 0) {\n            self.emit('warning', msg);\n        } else {\n            console.warn('node_redis:', msg);\n        }\n    });\n};\n\n// Flush provided queues, erroring any items with a callback first\nRedisClient.prototype.flush_and_error = function (error_attributes, options) {\n    options = options || {};\n    var aggregated_errors = [];\n    var queue_names = options.queues || ['command_queue', 'offline_queue']; // Flush the command_queue first to keep the order intakt\n    for (var i = 0; i < queue_names.length; i++) {\n        // If the command was fired it might have been processed so far\n        if (queue_names[i] === 'command_queue') {\n            error_attributes.message += ' It might have been processed.';\n        } else { // As the command_queue is flushed first, remove this for the offline queue\n            error_attributes.message = error_attributes.message.replace(' It might have been processed.', '');\n        }\n        // Don't flush everything from the queue\n        for (var command_obj = this[queue_names[i]].shift(); command_obj; command_obj = this[queue_names[i]].shift()) {\n            var err = new errorClasses.AbortError(error_attributes);\n            if (command_obj.error) {\n                err.stack = err.stack + command_obj.error.stack.replace(/^Error.*?\\n/, '\\n');\n            }\n            err.command = command_obj.command.toUpperCase();\n            if (command_obj.args && command_obj.args.length) {\n                err.args = command_obj.args;\n            }\n            if (options.error) {\n                err.origin = options.error;\n            }\n            if (typeof command_obj.callback === 'function') {\n                command_obj.callback(err);\n            } else {\n                aggregated_errors.push(err);\n            }\n        }\n    }\n    // Currently this would be a breaking change, therefore it's only emitted in debug_mode\n    if (exports.debug_mode && aggregated_errors.length) {\n        var error;\n        if (aggregated_errors.length === 1) {\n            error = aggregated_errors[0];\n        } else {\n            error_attributes.message = error_attributes.message.replace('It', 'They').replace(/command/i, '$&s');\n            error = new errorClasses.AggregateError(error_attributes);\n            error.errors = aggregated_errors;\n        }\n        this.emit('error', error);\n    }\n};\n\nRedisClient.prototype.on_error = function (err) {\n    if (this.closing) {\n        return;\n    }\n\n    err.message = 'Redis connection to ' + this.address + ' failed - ' + err.message;\n    debug(err.message);\n    this.connected = false;\n    this.ready = false;\n\n    // Only emit the error if the retry_stategy option is not set\n    if (!this.options.retry_strategy) {\n        this.emit('error', err);\n    }\n    // 'error' events get turned into exceptions if they aren't listened for. If the user handled this error\n    // then we should try to reconnect.\n    this.connection_gone('error', err);\n};\n\nRedisClient.prototype.on_connect = function () {\n    debug('Stream connected ' + this.address + ' id ' + this.connection_id);\n\n    this.connected = true;\n    this.ready = false;\n    this.emitted_end = false;\n    this.stream.setKeepAlive(this.options.socket_keepalive);\n    this.stream.setTimeout(0);\n\n    this.emit('connect');\n    this.initialize_retry_vars();\n\n    if (this.options.no_ready_check) {\n        this.on_ready();\n    } else {\n        this.ready_check();\n    }\n};\n\nRedisClient.prototype.on_ready = function () {\n    var self = this;\n\n    debug('on_ready called ' + this.address + ' id ' + this.connection_id);\n    this.ready = true;\n\n    this.cork = function () {\n        self.pipeline = true;\n        if (self.stream.cork) {\n            self.stream.cork();\n        }\n    };\n    this.uncork = function () {\n        if (self.fire_strings) {\n            self.write_strings();\n        } else {\n            self.write_buffers();\n        }\n        self.pipeline = false;\n        self.fire_strings = true;\n        if (self.stream.uncork) {\n            // TODO: Consider using next tick here. See https://github.com/NodeRedis/node_redis/issues/1033\n            self.stream.uncork();\n        }\n    };\n\n    // Restore modal commands from previous connection. The order of the commands is important\n    if (this.selected_db !== undefined) {\n        this.internal_send_command(new Command('select', [this.selected_db]));\n    }\n    if (this.monitoring) { // Monitor has to be fired before pub sub commands\n        this.internal_send_command(new Command('monitor', []));\n    }\n    var callback_count = Object.keys(this.subscription_set).length;\n    if (!this.options.disable_resubscribing && callback_count) {\n        // only emit 'ready' when all subscriptions were made again\n        // TODO: Remove the countdown for ready here. This is not coherent with all other modes and should therefore not be handled special\n        // We know we are ready as soon as all commands were fired\n        var callback = function () {\n            callback_count--;\n            if (callback_count === 0) {\n                self.emit('ready');\n            }\n        };\n        debug('Sending pub/sub on_ready commands');\n        for (var key in this.subscription_set) {\n            var command = key.slice(0, key.indexOf('_'));\n            var args = this.subscription_set[key];\n            this[command]([args], callback);\n        }\n        this.send_offline_queue();\n        return;\n    }\n    this.send_offline_queue();\n    this.emit('ready');\n};\n\nRedisClient.prototype.on_info_cmd = function (err, res) {\n    if (err) {\n        if (err.message === \"ERR unknown command 'info'\") {\n            this.on_ready();\n            return;\n        }\n        err.message = 'Ready check failed: ' + err.message;\n        this.emit('error', err);\n        return;\n    }\n\n    /* istanbul ignore if: some servers might not respond with any info data. This is just a safety check that is difficult to test */\n    if (!res) {\n        debug('The info command returned without any data.');\n        this.on_ready();\n        return;\n    }\n\n    if (!this.server_info.loading || this.server_info.loading === '0') {\n        // If the master_link_status exists but the link is not up, try again after 50 ms\n        if (this.server_info.master_link_status && this.server_info.master_link_status !== 'up') {\n            this.server_info.loading_eta_seconds = 0.05;\n        } else {\n            // Eta loading should change\n            debug('Redis server ready.');\n            this.on_ready();\n            return;\n        }\n    }\n\n    var retry_time = +this.server_info.loading_eta_seconds * 1000;\n    if (retry_time > 1000) {\n        retry_time = 1000;\n    }\n    debug('Redis server still loading, trying again in ' + retry_time);\n    setTimeout(function (self) {\n        self.ready_check();\n    }, retry_time, this);\n};\n\nRedisClient.prototype.ready_check = function () {\n    var self = this;\n    debug('Checking server ready state...');\n    // Always fire this info command as first command even if other commands are already queued up\n    this.ready = true;\n    this.info(function (err, res) {\n        self.on_info_cmd(err, res);\n    });\n    this.ready = false;\n};\n\nRedisClient.prototype.send_offline_queue = function () {\n    for (var command_obj = this.offline_queue.shift(); command_obj; command_obj = this.offline_queue.shift()) {\n        debug('Sending offline command: ' + command_obj.command);\n        this.internal_send_command(command_obj);\n    }\n    this.drain();\n};\n\nvar retry_connection = function (self, error) {\n    debug('Retrying connection...');\n\n    var reconnect_params = {\n        delay: self.retry_delay,\n        attempt: self.attempts,\n        error: error\n    };\n    if (self.options.camel_case) {\n        reconnect_params.totalRetryTime = self.retry_totaltime;\n        reconnect_params.timesConnected = self.times_connected;\n    } else {\n        reconnect_params.total_retry_time = self.retry_totaltime;\n        reconnect_params.times_connected = self.times_connected;\n    }\n    self.emit('reconnecting', reconnect_params);\n\n    self.retry_totaltime += self.retry_delay;\n    self.attempts += 1;\n    self.retry_delay = Math.round(self.retry_delay * self.retry_backoff);\n    self.create_stream();\n    self.retry_timer = null;\n};\n\nRedisClient.prototype.connection_gone = function (why, error) {\n    // If a retry is already in progress, just let that happen\n    if (this.retry_timer) {\n        return;\n    }\n    error = error || null;\n\n    debug('Redis connection is gone from ' + why + ' event.');\n    this.connected = false;\n    this.ready = false;\n    // Deactivate cork to work with the offline queue\n    this.cork = noop;\n    this.uncork = noop;\n    this.pipeline = false;\n    this.pub_sub_mode = 0;\n\n    // since we are collapsing end and close, users don't expect to be called twice\n    if (!this.emitted_end) {\n        this.emit('end');\n        this.emitted_end = true;\n    }\n\n    // If this is a requested shutdown, then don't retry\n    if (this.closing) {\n        debug('Connection ended by quit / end command, not retrying.');\n        this.flush_and_error({\n            message: 'Stream connection ended and command aborted.',\n            code: 'NR_CLOSED'\n        }, {\n            error: error\n        });\n        return;\n    }\n\n    if (typeof this.options.retry_strategy === 'function') {\n        var retry_params = {\n            attempt: this.attempts,\n            error: error\n        };\n        if (this.options.camel_case) {\n            retry_params.totalRetryTime = this.retry_totaltime;\n            retry_params.timesConnected = this.times_connected;\n        } else {\n            retry_params.total_retry_time = this.retry_totaltime;\n            retry_params.times_connected = this.times_connected;\n        }\n        this.retry_delay = this.options.retry_strategy(retry_params);\n        if (typeof this.retry_delay !== 'number') {\n            // Pass individual error through\n            if (this.retry_delay instanceof Error) {\n                error = this.retry_delay;\n            }\n            this.flush_and_error({\n                message: 'Stream connection ended and command aborted.',\n                code: 'NR_CLOSED'\n            }, {\n                error: error\n            });\n            this.end(false);\n            return;\n        }\n    }\n\n    if (this.max_attempts !== 0 && this.attempts >= this.max_attempts || this.retry_totaltime >= this.connect_timeout) {\n        var message = 'Redis connection in broken state: ';\n        if (this.retry_totaltime >= this.connect_timeout) {\n            message += 'connection timeout exceeded.';\n        } else {\n            message += 'maximum connection attempts exceeded.';\n        }\n\n        this.flush_and_error({\n            message: message,\n            code: 'CONNECTION_BROKEN',\n        }, {\n            error: error\n        });\n        var err = new Error(message);\n        err.code = 'CONNECTION_BROKEN';\n        if (error) {\n            err.origin = error;\n        }\n        this.emit('error', err);\n        this.end(false);\n        return;\n    }\n\n    // Retry commands after a reconnect instead of throwing an error. Use this with caution\n    if (this.options.retry_unfulfilled_commands) {\n        this.offline_queue.unshift.apply(this.offline_queue, this.command_queue.toArray());\n        this.command_queue.clear();\n    } else if (this.command_queue.length !== 0) {\n        this.flush_and_error({\n            message: 'Redis connection lost and command aborted.',\n            code: 'UNCERTAIN_STATE'\n        }, {\n            error: error,\n            queues: ['command_queue']\n        });\n    }\n\n    if (this.retry_max_delay !== null && this.retry_delay > this.retry_max_delay) {\n        this.retry_delay = this.retry_max_delay;\n    } else if (this.retry_totaltime + this.retry_delay > this.connect_timeout) {\n        // Do not exceed the maximum\n        this.retry_delay = this.connect_timeout - this.retry_totaltime;\n    }\n\n    debug('Retry connection in ' + this.retry_delay + ' ms');\n\n    this.retry_timer = setTimeout(retry_connection, this.retry_delay, this, error);\n};\n\nRedisClient.prototype.return_error = function (err) {\n    var command_obj = this.command_queue.shift();\n    if (command_obj.error) {\n        err.stack = command_obj.error.stack.replace(/^Error.*?\\n/, 'ReplyError: ' + err.message + '\\n');\n    }\n    err.command = command_obj.command.toUpperCase();\n    if (command_obj.args && command_obj.args.length) {\n        err.args = command_obj.args;\n    }\n\n    // Count down pub sub mode if in entering modus\n    if (this.pub_sub_mode > 1) {\n        this.pub_sub_mode--;\n    }\n\n    var match = err.message.match(utils.err_code);\n    // LUA script could return user errors that don't behave like all other errors!\n    if (match) {\n        err.code = match[1];\n    }\n\n    utils.callback_or_emit(this, command_obj.callback, err);\n};\n\nRedisClient.prototype.drain = function () {\n    this.emit('drain');\n    this.should_buffer = false;\n};\n\nRedisClient.prototype.emit_idle = function () {\n    if (this.command_queue.length === 0 && this.pub_sub_mode === 0) {\n        this.emit('idle');\n    }\n};\n\nfunction normal_reply (self, reply) {\n    var command_obj = self.command_queue.shift();\n    if (typeof command_obj.callback === 'function') {\n        if (command_obj.command !== 'exec') {\n            reply = self.handle_reply(reply, command_obj.command, command_obj.buffer_args);\n        }\n        command_obj.callback(null, reply);\n    } else {\n        debug('No callback for reply');\n    }\n}\n\nfunction subscribe_unsubscribe (self, reply, type) {\n    // Subscribe commands take an optional callback and also emit an event, but only the _last_ response is included in the callback\n    // The pub sub commands return each argument in a separate return value and have to be handled that way\n    var command_obj = self.command_queue.get(0);\n    var buffer = self.options.return_buffers || self.options.detect_buffers && command_obj.buffer_args;\n    var channel = (buffer || reply[1] === null) ? reply[1] : reply[1].toString();\n    var count = +reply[2]; // Return the channel counter as number no matter if `string_numbers` is activated or not\n    debug(type, channel);\n\n    // Emit first, then return the callback\n    if (channel !== null) { // Do not emit or \"unsubscribe\" something if there was no channel to unsubscribe from\n        self.emit(type, channel, count);\n        if (type === 'subscribe' || type === 'psubscribe') {\n            self.subscription_set[type + '_' + channel] = channel;\n        } else {\n            type = type === 'unsubscribe' ? 'subscribe' : 'psubscribe'; // Make types consistent\n            delete self.subscription_set[type + '_' + channel];\n        }\n    }\n\n    if (command_obj.args.length === 1 || self.sub_commands_left === 1 || command_obj.args.length === 0 && (count === 0 || channel === null)) {\n        if (count === 0) { // unsubscribed from all channels\n            var running_command;\n            var i = 1;\n            self.pub_sub_mode = 0; // Deactivating pub sub mode\n            // This should be a rare case and therefore handling it this way should be good performance wise for the general case\n            while (running_command = self.command_queue.get(i)) {\n                if (SUBSCRIBE_COMMANDS[running_command.command]) {\n                    self.pub_sub_mode = i; // Entering pub sub mode again\n                    break;\n                }\n                i++;\n            }\n        }\n        self.command_queue.shift();\n        if (typeof command_obj.callback === 'function') {\n            // TODO: The current return value is pretty useless.\n            // Evaluate to change this in v.3 to return all subscribed / unsubscribed channels in an array including the number of channels subscribed too\n            command_obj.callback(null, channel);\n        }\n        self.sub_commands_left = 0;\n    } else {\n        if (self.sub_commands_left !== 0) {\n            self.sub_commands_left--;\n        } else {\n            self.sub_commands_left = command_obj.args.length ? command_obj.args.length - 1 : count;\n        }\n    }\n}\n\nfunction return_pub_sub (self, reply) {\n    var type = reply[0].toString();\n    if (type === 'message') { // channel, message\n        if (!self.options.return_buffers || self.message_buffers) { // backwards compatible. Refactor this in v.3 to always return a string on the normal emitter\n            self.emit('message', reply[1].toString(), reply[2].toString());\n            self.emit('message_buffer', reply[1], reply[2]);\n            self.emit('messageBuffer', reply[1], reply[2]);\n        } else {\n            self.emit('message', reply[1], reply[2]);\n        }\n    } else if (type === 'pmessage') { // pattern, channel, message\n        if (!self.options.return_buffers || self.message_buffers) { // backwards compatible. Refactor this in v.3 to always return a string on the normal emitter\n            self.emit('pmessage', reply[1].toString(), reply[2].toString(), reply[3].toString());\n            self.emit('pmessage_buffer', reply[1], reply[2], reply[3]);\n            self.emit('pmessageBuffer', reply[1], reply[2], reply[3]);\n        } else {\n            self.emit('pmessage', reply[1], reply[2], reply[3]);\n        }\n    } else {\n        subscribe_unsubscribe(self, reply, type);\n    }\n}\n\nRedisClient.prototype.return_reply = function (reply) {\n    if (this.monitoring) {\n        var replyStr;\n        if (this.buffers && Buffer.isBuffer(reply)) {\n            replyStr = reply.toString();\n        } else {\n            replyStr = reply;\n        }\n        // If in monitor mode, all normal commands are still working and we only want to emit the streamlined commands\n        if (typeof replyStr === 'string' && utils.monitor_regex.test(replyStr)) {\n            var timestamp = replyStr.slice(0, replyStr.indexOf(' '));\n            var args = replyStr.slice(replyStr.indexOf('\"') + 1, -1).split('\" \"').map(function (elem) {\n                return elem.replace(/\\\\\"/g, '\"');\n            });\n            this.emit('monitor', timestamp, args, replyStr);\n            return;\n        }\n    }\n    if (this.pub_sub_mode === 0) {\n        normal_reply(this, reply);\n    } else if (this.pub_sub_mode !== 1) {\n        this.pub_sub_mode--;\n        normal_reply(this, reply);\n    } else if (!(reply instanceof Array) || reply.length <= 2) {\n        // Only PING and QUIT are allowed in this context besides the pub sub commands\n        // Ping replies with ['pong', null|value] and quit with 'OK'\n        normal_reply(this, reply);\n    } else {\n        return_pub_sub(this, reply);\n    }\n};\n\nfunction handle_offline_command (self, command_obj) {\n    var command = command_obj.command;\n    var err, msg;\n    if (self.closing || !self.enable_offline_queue) {\n        command = command.toUpperCase();\n        if (!self.closing) {\n            if (self.stream.writable) {\n                msg = 'The connection is not yet established and the offline queue is deactivated.';\n            } else {\n                msg = 'Stream not writeable.';\n            }\n        } else {\n            msg = 'The connection is already closed.';\n        }\n        err = new errorClasses.AbortError({\n            message: command + \" can't be processed. \" + msg,\n            code: 'NR_CLOSED',\n            command: command\n        });\n        if (command_obj.args.length) {\n            err.args = command_obj.args;\n        }\n        utils.reply_in_order(self, command_obj.callback, err);\n    } else {\n        debug('Queueing ' + command + ' for next server connection.');\n        self.offline_queue.push(command_obj);\n    }\n    self.should_buffer = true;\n}\n\n// Do not call internal_send_command directly, if you are not absolutly certain it handles everything properly\n// e.g. monitor / info does not work with internal_send_command only\nRedisClient.prototype.internal_send_command = function (command_obj) {\n    var arg, prefix_keys;\n    var i = 0;\n    var command_str = '';\n    var args = command_obj.args;\n    var command = command_obj.command;\n    var len = args.length;\n    var big_data = false;\n    var args_copy = new Array(len);\n\n    if (process.domain && command_obj.callback) {\n        command_obj.callback = process.domain.bind(command_obj.callback);\n    }\n\n    if (this.ready === false || this.stream.writable === false) {\n        // Handle offline commands right away\n        handle_offline_command(this, command_obj);\n        return false; // Indicate buffering\n    }\n\n    for (i = 0; i < len; i += 1) {\n        if (typeof args[i] === 'string') {\n            // 30000 seemed to be a good value to switch to buffers after testing and checking the pros and cons\n            if (args[i].length > 30000) {\n                big_data = true;\n                args_copy[i] = new Buffer(args[i], 'utf8');\n            } else {\n                args_copy[i] = args[i];\n            }\n        } else if (typeof args[i] === 'object') { // Checking for object instead of Buffer.isBuffer helps us finding data types that we can't handle properly\n            if (args[i] instanceof Date) { // Accept dates as valid input\n                args_copy[i] = args[i].toString();\n            } else if (args[i] === null) {\n                this.warn(\n                    'Deprecated: The ' + command.toUpperCase() + ' command contains a \"null\" argument.\\n' +\n                    'This is converted to a \"null\" string now and will return an error from v.3.0 on.\\n' +\n                    'Please handle this in your code to make sure everything works as you intended it to.'\n                );\n                args_copy[i] = 'null'; // Backwards compatible :/\n            } else if (Buffer.isBuffer(args[i])) {\n                args_copy[i] = args[i];\n                command_obj.buffer_args = true;\n                big_data = true;\n            } else {\n                this.warn(\n                    'Deprecated: The ' + command.toUpperCase() + ' command contains a argument of type ' + args[i].constructor.name + '.\\n' +\n                    'This is converted to \"' + args[i].toString() + '\" by using .toString() now and will return an error from v.3.0 on.\\n' +\n                    'Please handle this in your code to make sure everything works as you intended it to.'\n                );\n                args_copy[i] = args[i].toString(); // Backwards compatible :/\n            }\n        } else if (typeof args[i] === 'undefined') {\n            this.warn(\n                'Deprecated: The ' + command.toUpperCase() + ' command contains a \"undefined\" argument.\\n' +\n                'This is converted to a \"undefined\" string now and will return an error from v.3.0 on.\\n' +\n                'Please handle this in your code to make sure everything works as you intended it to.'\n            );\n            args_copy[i] = 'undefined'; // Backwards compatible :/\n        } else {\n            // Seems like numbers are converted fast using string concatenation\n            args_copy[i] = '' + args[i];\n        }\n    }\n\n    if (this.options.prefix) {\n        prefix_keys = commands.getKeyIndexes(command, args_copy);\n        for (i = prefix_keys.pop(); i !== undefined; i = prefix_keys.pop()) {\n            args_copy[i] = this.options.prefix + args_copy[i];\n        }\n    }\n    if (this.options.rename_commands && this.options.rename_commands[command]) {\n        command = this.options.rename_commands[command];\n    }\n    // Always use 'Multi bulk commands', but if passed any Buffer args, then do multiple writes, one for each arg.\n    // This means that using Buffers in commands is going to be slower, so use Strings if you don't already have a Buffer.\n    command_str = '*' + (len + 1) + '\\r\\n$' + command.length + '\\r\\n' + command + '\\r\\n';\n\n    if (big_data === false) { // Build up a string and send entire command in one write\n        for (i = 0; i < len; i += 1) {\n            arg = args_copy[i];\n            command_str += '$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n';\n        }\n        debug('Send ' + this.address + ' id ' + this.connection_id + ': ' + command_str);\n        this.write(command_str);\n    } else {\n        debug('Send command (' + command_str + ') has Buffer arguments');\n        this.fire_strings = false;\n        this.write(command_str);\n\n        for (i = 0; i < len; i += 1) {\n            arg = args_copy[i];\n            if (typeof arg === 'string') {\n                this.write('$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n');\n            } else { // buffer\n                this.write('$' + arg.length + '\\r\\n');\n                this.write(arg);\n                this.write('\\r\\n');\n            }\n            debug('send_command: buffer send ' + arg.length + ' bytes');\n        }\n    }\n    if (command_obj.call_on_write) {\n        command_obj.call_on_write();\n    }\n    // Handle `CLIENT REPLY ON|OFF|SKIP`\n    // This has to be checked after call_on_write\n    /* istanbul ignore else: TODO: Remove this as soon as we test Redis 3.2 on travis */\n    if (this.reply === 'ON') {\n        this.command_queue.push(command_obj);\n    } else {\n        // Do not expect a reply\n        // Does this work in combination with the pub sub mode?\n        if (command_obj.callback) {\n            utils.reply_in_order(this, command_obj.callback, null, undefined, this.command_queue);\n        }\n        if (this.reply === 'SKIP') {\n            this.reply = 'SKIP_ONE_MORE';\n        } else if (this.reply === 'SKIP_ONE_MORE') {\n            this.reply = 'ON';\n        }\n    }\n    return !this.should_buffer;\n};\n\nRedisClient.prototype.write_strings = function () {\n    var str = '';\n    for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n        // Write to stream if the string is bigger than 4mb. The biggest string may be Math.pow(2, 28) - 15 chars long\n        if (str.length + command.length > 4 * 1024 * 1024) {\n            this.should_buffer = !this.stream.write(str);\n            str = '';\n        }\n        str += command;\n    }\n    if (str !== '') {\n        this.should_buffer = !this.stream.write(str);\n    }\n};\n\nRedisClient.prototype.write_buffers = function () {\n    for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n        this.should_buffer = !this.stream.write(command);\n    }\n};\n\nRedisClient.prototype.write = function (data) {\n    if (this.pipeline === false) {\n        this.should_buffer = !this.stream.write(data);\n        return;\n    }\n    this.pipeline_queue.push(data);\n};\n\nObject.defineProperty(exports, 'debugMode', {\n    get: function () {\n        return this.debug_mode;\n    },\n    set: function (val) {\n        this.debug_mode = val;\n    }\n});\n\n// Don't officially expose the command_queue directly but only the length as read only variable\nObject.defineProperty(RedisClient.prototype, 'command_queue_length', {\n    get: function () {\n        return this.command_queue.length;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'offline_queue_length', {\n    get: function () {\n        return this.offline_queue.length;\n    }\n});\n\n// Add support for camelCase by adding read only properties to the client\n// All known exposed snake_case variables are added here\nObject.defineProperty(RedisClient.prototype, 'retryDelay', {\n    get: function () {\n        return this.retry_delay;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'retryBackoff', {\n    get: function () {\n        return this.retry_backoff;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'commandQueueLength', {\n    get: function () {\n        return this.command_queue.length;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'offlineQueueLength', {\n    get: function () {\n        return this.offline_queue.length;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'shouldBuffer', {\n    get: function () {\n        return this.should_buffer;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'connectionId', {\n    get: function () {\n        return this.connection_id;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'serverInfo', {\n    get: function () {\n        return this.server_info;\n    }\n});\n\nexports.createClient = function () {\n    return new RedisClient(unifyOptions.apply(null, arguments));\n};\nexports.RedisClient = RedisClient;\nexports.print = utils.print;\nexports.Multi = require('./lib/multi');\nexports.AbortError = errorClasses.AbortError;\nexports.RedisError = Parser.RedisError;\nexports.ParserError = Parser.ParserError;\nexports.ReplyError = Parser.ReplyError;\nexports.AggregateError = errorClasses.AggregateError;\n\n// Add all redis commands / node_redis api to the client\nrequire('./lib/individualCommands');\nrequire('./lib/extendedApi');\n\n//enables adding new commands (for modules and new commands)\nexports.addCommand = exports.add_command = require('./lib/commands');"]},"metadata":{},"sourceType":"script"}